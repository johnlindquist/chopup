This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor/
  rules/
    _global.mdc
    _project.mdc
    cli-github-search.mdc
    cli-pack.mdc
    cli-wrangler.mdc
    docs-diagram.mdc
    docs-openapi-spec.mdc
    docs-prd.mdc
    docs-structure.mdc
    docs-sync.mdc
    docs-tech-stack.mdc
    pnpm-fixes.mdc
    project-todos-next.mdc
    project-update-rules.mdc
    project-worktrees.mdc
    prompt-improve.mdc
    pull-request-create.mdc
    react-rules.mdc
    scripts-create.mdc
    task-execute.mdc
    task-next.mdc
    task-plan.mdc
    zen-coding.mdc
.github/
  workflows/
    ci.yml
    release.yml
docs/
  tasks/
    2025-05-09-fix-input-integration-test-failures.md
    2025-05-09-fix-tests.md
    2025-05-09-input-integration-tests.md
    2025-05-09-send-flag-interactive-input.md
    2025-05-10-decrease-test-timeouts.md
src/
  index.ts
test/
  integration/
    input-tests/
      fixtures/
        scripts/
          echo-input.js
          text-entry-prompt.js
          yes-no-prompt.js
      single-char.test.ts
      smoke.test.ts
      text-entry.test.ts
    test-utils/
      input-helpers.ts
    spawn-wrapper-ipc-request-logs.test.d.ts
    spawn-wrapper-ipc-request-logs.test.ts
    spawn-wrapper-nextjs-dev.test.d.ts
    spawn-wrapper-nextjs-dev.test.ts
    spawn-wrapper-passthrough.test.ts
    spawn-wrapper-send-flag.test.ts
.gitignore
package.json
README.md
release.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches-ignore: [main]
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          run_install: false

      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: pnpm

      - name: Log Node, pnpm, npm versions
        run: |
          node -v
          pnpm -v
          npm -v

      - name: Install dependencies
        run: pnpm install --frozen-lockfile --strict-peer-dependencies

      - name: Build
        run: pnpm run build

      - name: Run tests (vitest)
        run: pnpm run test:ci || pnpm run test

      - name: List dist contents
        run: ls -l dist || echo 'dist missing'

  cross-platform:
    needs: build
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with:
          run_install: false
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: pnpm
      - name: Install dependencies
        run: pnpm install --prod --frozen-lockfile
      - name: List dist contents
        run: ls -l dist || echo 'dist missing'
      - name: Run smoke test (echo)
        run: echo "Smoke test on ${{ runner.os }}"
</file>

<file path=".github/workflows/release.yml">
name: Release Package

on:
  push:
    branches:
      - main

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

jobs:
  release:
    name: Create Release and Publish NPM Package
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0

      - uses: pnpm/action-setup@v4
        with:
          run_install: false

      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: pnpm
          registry-url: "https://registry.npmjs.org"

      - name: Log Node, pnpm, npm versions
        run: |
          node -v
          pnpm -v
          npm -v

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build project (Pre-Release Check)
        run: pnpm run build

      - name: Run semantic-release
        id: semantic
        uses: cycjimmy/semantic-release-action@v4
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Build project (Post-Release Version)
        if: steps.semantic.outputs.new_release_published == 'true'
        run: pnpm run build

      - name: Publish to NPM
        if: steps.semantic.outputs.new_release_published == 'true'
        run: pnpm publish --access public --no-git-checks
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Output Publish Status (Published)
        if: steps.semantic.outputs.new_release_published == 'true'
        run: echo "✅ New version ${{ steps.semantic.outputs.new_release_version }} tagged, released on GitHub, and published to npm."

      - name: Output Publish Status (Not Published)
        if: steps.semantic.outputs.new_release_published != 'true'
        run: echo "ℹ️ No new version published."
</file>

<file path="docs/tasks/2025-05-09-fix-input-integration-test-failures.md">
# Task: Fix Input Integration Test Failures and Ensure CLI Compatibility

## Commit 1: fix: Suppress all debug logs for send-input except expected output ✅ <SHA1>
**Description:**
Patch `src/index.ts` so that when running the `send-input` command, only `INPUT_SENT`, `INPUT_SEND_ERROR`, or `INPUT_SEND_ERROR_NO_CHILD` are printed to stdout. All other debug or info logs must be suppressed for this command. Patch `console.log` just before the `.action` handler for `send-input` to avoid global suppression. This ensures test output matches the expectations in `test/integration/input-tests/` and `test/integration/spawn-wrapper-send-flag.test.ts`.

**Verification:**
- Run `pnpm test` and confirm all tests in `test/integration/input-tests/` and `test/integration/spawn-wrapper-send-flag.test.ts` pass.
- Manually run `chopup send-input --socket <socket> --input "y"` and confirm only `INPUT_SENT` is printed.

---

## Commit 2: fix: Print connection errors to stderr for send-input failures ✅ <SHA2>
**Description:**
Update the `send-input` command in `src/index.ts` to print connection errors (e.g., invalid socket, exited process) to stderr using `console.error`. Ensure the error message matches the format expected by tests (see `test/integration/input-tests/` and README troubleshooting section). Do not print any other logs for successful input sends.

**Verification:**
- Run tests that simulate invalid socket or exited process scenarios (e.g., kill the wrapped process, then run `send-input`).
- Confirm error messages are printed to stderr and tests pass.

---

## Commit 3: fix: Remove global log suppression for send-input ✅ <SHA3>
**Description:**
Ensure that any global patching of `console.log` or `console.error` for the `send-input` command is removed from the top of `src/index.ts`. The patch should only be applied locally within the `.action` handler for `send-input`. This prevents suppression of logs for other commands and ensures correct output for all CLI subcommands.

**Verification:**
- Run all CLI commands (`run`, `request-logs`, `send-input`) and confirm only `send-input` output is suppressed as expected.
- Run `pnpm test` and confirm all tests pass.

---

## Commit 4: fix: Ensure INPUT_SENT is always printed for successful input
**Description:**
Update the `send-input` command in `src/index.ts` so that `INPUT_SENT` is always printed to stdout when the server responds with `INPUT_SENT`, even if debug log suppression is active. This guarantees test output is correct and matches the expectations in `test/integration/input-tests/`.

**Verification:**
- Run `pnpm test` and confirm all tests in `test/integration/input-tests/` pass.
- Manually verify that `chopup send-input --socket <socket> --input "test"` prints `INPUT_SENT` on success.

---

## Commit 5: chore: Refactor and document log suppression logic
**Description:**
Refactor the log suppression logic for `send-input` in `src/index.ts` to a dedicated helper function or inline comment for maintainability. Update `README.md` to document the log suppression behavior for `send-input` and clarify expected output for integration tests and troubleshooting.

**Verification:**
- Code review to ensure log suppression is isolated and documented.
- Check `README.md` for updated documentation on `send-input` output and troubleshooting.
- Run `pnpm test` to confirm all tests pass after refactor.

---
</file>

<file path="docs/tasks/2025-05-09-fix-tests.md">
# Task: Resolve Test Failures for `send-input` and Socket Cleanup

## Commit 1: fix: Correct `mainAction` invocation and argument parsing in `src/index.ts` ✅ 6600457bc6a0fe4d7a897da6abe01918ef3389af

**Description:**
The `mainAction` function, when used as the action handler for the `run` command, was not correctly receiving `this` as the Commander `Command` instance due to an incorrect intermediary async arrow function. This commit will:
1.  Modify the `.action()` call for the `run` command in `src/index.ts` to pass `mainAction` directly, allowing Commander to bind `this` correctly.
2.  Update the signature of `mainAction` to `async function mainAction(this: Command, commandToRunArgs: string[], cmdOptionsObj: Record<string, any>)`.
3.  Adjust the internal logic of `mainAction` to correctly extract the command to run (`commandToExecute`) and its arguments (`argsForCommand`) from `commandToRunArgs` (for direct arguments) or `this.opts().passthrough` (for passthrough arguments). Named options like `logDir` and `socketPath` will be read from `this.opts()`.
    *   Files affected: `src/index.ts`

**Verification:**
1.  **Integration Test:**
    *   Run: `pnpm test test/integration/spawn-wrapper-passthrough.test.ts`
    *   Expected outcome: The "should chop logs on IPC request (echo passthrough)" test should now pass. The timeout error due to `this.opts()` being undefined should be resolved. The test logs should show the wrapper starting correctly and processing the passthrough command.
2.  **Integration Test:**
    *   Run: `pnpm test test/integration/spawn-wrapper-ipc-request-logs.test.ts`
    *   Expected outcome: The "should create log files on IPC chop request" test should now pass. The timeout error due to `this.opts()` being undefined should be resolved.
3.  **Log Check:**
    *   Observe the general test output when running any test that spawns the wrapper (e.g., `spawn-wrapper-send-flag.test.ts`). The `[WRAPPER_STDOUT]` logs should no longer show the `TypeError: Cannot read properties of undefined (reading 'opts')`.
    *   The wrapper should print its configuration (log directory, command to run) correctly.

---

## Commit 2: fix: Ensure `send-input` correctly outputs status and handles IPC client lifecycle ✅ e57f03a9bd7494400e54f398bd118cdb3f04084e

**Description:**
The `send-input` command was experiencing issues with `ERR_STREAM_WRITE_AFTER_END` on the server side and its own output (`INPUT_SENT`) not being reliably captured. This commit will:
1.  Modify the `send-input` action handler in `src/index.ts`:
    *   When the server sends `INPUT_SENT` (or an error message) back to the `send-input` client:
        a.  The client will use `process.stdout.write('MESSAGE\n', () => { /* callback */ });` (or `process.stderr.write` for actual errors) to ensure the message is flushed.
        b.  Inside this `write` callback, it will then call `client.end()` to gracefully close its end of the IPC connection.
        c.  In the `client.on('close', ...)` handler, it will then call `process.exit(code)`.
2.  Modify the IPC server logic in `mainAction` (within the `Chopup` class `setupIpcServer` method):
    *   When the server successfully writes `INPUT_SENT` to the `clientSocket` (the one connected to `send-input`):
        a.  It will *not* call `socket.end()` on its side. It will rely on the `send-input` client to close its end after flushing its stdout.
    *   If the server encounters an error writing `INPUT_SENT` *or* is sending an error like `INPUT_SEND_ERROR`, then it *will* call `socket.end()` (if writable) on its side.
    *   Files affected: `src/index.ts` (both `send-input` action and `Chopup` class's IPC handling).

**Verification:**
1.  **Integration Test:**
    *   Run: `pnpm test test/integration/spawn-wrapper-send-flag.test.ts`
    *   Specific check for `should send input to a wrapped process via send-input command and allow it to proceed`:
        *   The `ERR_STREAM_WRITE_AFTER_END` error in the wrapper's (server's) IPC logs should be gone.
        *   The `[SEND_INPUT_HELPER_SPAWN_EXIT]` log from `input-helpers.ts` should now show `Stdout: "INPUT_SENT\n"`.
        *   The assertion `expect(stdout).toContain('INPUT_SENT');` in the test should now pass.
        *   The test should no longer time out.
    *   Specific check for `should fail gracefully if the target socket path is invalid`:
        *   The `send-input` command's `stdout` (captured as `execStdout` in the test) should contain `CHOPUP_INPUT_SEND_ERROR_NO_SERVER`.
        *   `execError` should be non-null and `execError.code` should be 1.
        *   `execStderr` should be empty.
    *   Specific check for `should fail gracefully if the wrapped process has already exited`:
        *   The `send-input` command's `stdout` should contain `CHOPUP_INPUT_SEND_ERROR_NO_SERVER` (most likely) or `CHOPUP_INPUT_SEND_ERROR_NO_CHILD`.
        *   `execError` should be non-null and `execError.code` should be 1.
        *   `execStderr` should be empty.
2.  **Log Check:**
    *   Observe the test output. For successful `send-input` calls, the wrapper should log `[IPC_SERVER] Successfully sent INPUT_SENT to client. Client will flush, end socket, then exit.`
    *   The `send-input` client's internal logs (if any are unsuppressed temporarily for debugging) should show it entering the `write` callback before `client.end()` and then `process.exit()` in the `close` handler.

---

## Commit 3: fix: Correct test assertions for wrapper output prefix ✅ e51779dd07992b484eb25c456c840d664aa7c19a

**Description:**
The tests in `spawn-wrapper-send-flag.test.ts` were asserting for `CHOPUP_CHILD_PID=` and `CHOPUP_SOCKET_PATH=` directly in the wrapper's output. However, the `logToConsole` method in the `Chopup` class prepends `[chopup_wrapper] ` to these messages. This commit will update these assertions.
The test for `INPUT_SENT` will also be updated to expect it from the wrapper's stdout with the prefix.
1.  Modify `test/integration/spawn-wrapper-send-flag.test.ts`:
    *   Change `expect(wrapperOutput).toContain('CHOPUP_CHILD_PID=');` to `expect(wrapperOutput).toContain('[chopup_wrapper] CHOPUP_CHILD_PID=');`
    *   Change `expect(wrapperOutput).toContain('CHOPUP_SOCKET_PATH=');` to `expect(wrapperOutput).toContain('[chopup_wrapper] CHOPUP_SOCKET_PATH=');`
    *   Change `expect(wrapperOutput).toContain('CHOPUP_INPUT_SENT');` to `expect(wrapperOutput).toContain('[chopup_wrapper] CHOPUP_INPUT_SENT');`
    *   Files affected: `test/integration/spawn-wrapper-send-flag.test.ts`

**Verification:**
1.  **Integration Test:**
    *   Run: `pnpm test test/integration/spawn-wrapper-send-flag.test.ts`
    *   Expected outcome: The test `should send input to a wrapped process via send-input command and allow it to proceed` should now pass all its assertions related to `wrapperOutput` content. If Commit 2 was successful, the entire test should pass.
2.  **Log Check:**
    *   No specific new log checks, but verify the test passes and the wrapper logs show the prefixed messages.

---

## Commit 4: fix: Address EPIPE error in wrapper's `logToConsole` and improve socket cleanup resilience ✅ ce59c3150f89e1e8f21f219599f5d00cd79042e0

**Description:**
The main wrapper process was encountering an `EPIPE` error when `logToConsole` was called during shutdown, indicating its `stdout` (or `stderr` fallback) was already closed. Additionally, the socket cleanup for `smoke.test.ts` remains an issue.
This commit will:
1.  In `src/index.ts` (`Chopup` class):
    *   Modify `logToConsole`: If both `process.stdout.writable` and `process.stderr.writable` are false, avoid trying to write, to prevent EPIPE. This is a safeguard for very late-stage logging.
    *   In `performFinalCleanup`: Ensure `treeKill` has a timeout. If `treeKill` hangs or fails to call its callback, the cleanup might stall. Add a timeout that forces `performFinalCleanup` to proceed to IPC server closing and socket unlinking after a reasonable delay (e.g., 1-2 seconds) if `treeKill` callback hasn't fired.
    *   In `attemptSocketUnlinkOnExit`: Add a small, brief delay (e.g., 100-200ms) *before* `fsSync.unlinkSync(this.socketPath);` to give the OS a moment to release file handles if the `ipcServer.close()` callback was extremely quick. This is a cautious addition for the stubborn `smoke.test.ts` issue. Log before and after this delay.
    *   Ensure the `process.on('exit', ...)` handler in `Chopup` class calls `attemptSocketUnlinkOnExit` *synchronously* as intended, as it's a last-ditch effort.
    *   Files affected: `src/index.ts`

**Verification:**
1.  **Integration Test:**
    *   Run: `pnpm test test/integration/input-tests/smoke.test.ts`
    *   Expected outcome: The test `should successfully send input to a wrapped script and verify its output` should now pass. Specifically, `expect(socketGone).toBe(true);` should hold.
2.  **Log Check:**
    *   Observe the `smoke.test.ts` wrapper logs. They should show:
        *   `[DEBUG] attemptSocketUnlinkAndExit: Received sockPath='...' ...`
        *   Potentially a log about the pre-unlink delay if added.
        *   `[DEBUG] Socket file '...' exists. Unlinking...`
        *   `[DEBUG] Socket file '...' unlinked successfully.`
        *   `[WRAPPER] Exiting with code 0.`
    *   The `EPIPE` error should no longer appear in the main test output from any test. If `logToConsole` hits a non-writable stream, it should now be silent or log the fallback path only once.

---

## Commit 5: refactor: Finalize logging and remove temporary debug statements ✅ ce59c3150f89e1e8f21f219599f5d00cd79042e0

**Description:**
Review all `console.log`, `console.error`, `process.stdout.write`, `process.stderr.write` calls added during debugging in both `src/index.ts` and test files.
1.  Remove or comment out verbose debug logs that are no longer necessary for standard operation (e.g., very frequent IPC message logs, excessive pre/post logging for minor operations).
2.  Ensure all intentional logging from the `Chopup` wrapper class uses its `this.log()` or `this.logToConsole()` methods.
3.  Ensure `send-input` command only outputs `INPUT_SENT` (or error codes like `CHOPUP_INPUT_SEND_ERROR_...`) to its `stdout` on success/controlled failure, and is otherwise silent on `stderr`.
4.  Confirm that `suppressSendInputLogs()` effectively mutes any unintended console noise from the `send-input` command itself.
    *   Files affected: `src/index.ts`, `test/integration/test-utils/input-helpers.ts`, potentially `test/integration/spawn-wrapper-send-flag.test.ts` if it has temporary logs.

**Verification:**
1.  **All Tests Pass:**
    *   Run: `pnpm test`
    *   Expected outcome: All tests should pass. There should be no `ERR_STREAM_WRITE_AFTER_END`, `EPIPE`, or unhandled `AssertionError` in the test output.
2.  **Clean Log Output:**
    *   Briefly inspect the test output. It should be relatively clean, with primary output coming from the test runner (Vitest) and intentional diagnostic messages from the tests/helpers (e.g., `[TEST_RUN]...`, `[SMOKE_TEST]...`). Wrapper-specific operational logs should be minimal unless `LOG_LEVEL` (or equivalent) is set high.
    *   The `send-input` command, when run by tests, should only show `INPUT_SENT` (or `CHOPUP_...` error codes) on its stdout capture, and nothing on its stderr capture for controlled scenarios.
</file>

<file path="docs/tasks/2025-05-10-decrease-test-timeouts.md">
# Task: Decrease Test Timeouts and Tackle Input Integration Tests Individually

## Commit 1: chore: Decrease all input integration test timeouts to 5s and add excessive logging ✅ c1e6f2d
**Description:**
Reduce all `it(..., <timeout>)` values in `test/integration/input-tests/smoke.test.ts`, `single-char.test.ts`, and `text-entry.test.ts` from 20s to 5s. Add `console.log` statements before/after every async wait, input send, and output check in each test. Update `spawnChopupWithScript` in `test/integration/test-utils/input-helpers.ts` to default to a 5s timeout for socket detection. Ensure all dummy scripts in `fixtures/scripts/` log when they start, receive input, and exit.

**Verification:**
- Run `pnpm test test/integration/input-tests/smoke.test.ts` and confirm all tests fail fast if they hang, and logs show all key events.
- Manually inspect logs for prompt, input, and output events in each test run.

---

## Commit 2: fix: Tackle smoke.test.ts - ensure robust, fast cleanup and socket removal ✅ d196caa
**Description:**
Refactor `smoke.test.ts` to minimize all waits (e.g., reduce `setTimeout`/polling intervals to 100ms, max 1s total). Ensure `chopupInstance.cleanup()` is always awaited and logs before/after cleanup. Add a final check for socket file removal with a 1s poll. If socket is not removed, log error and fail test immediately.

**Verification:**
- Run `pnpm test test/integration/input-tests/smoke.test.ts` and confirm it passes in <5s, logs all cleanup steps, and fails if socket lingers.
- Check for `[SMOKE_TEST]` logs before/after each major step.

---

## Commit 3: fix: Tackle single-char.test.ts - minimize delays and verify all edge cases ✅ f60cef5
**Description:**
Reduce all `setTimeout`/waits in `single-char.test.ts` to 100-200ms. Add logs before/after each input send and output check. Ensure each test case (`y`, `N`, invalid) logs the input, output, and cleanup. Fail immediately if output is not as expected within 1s. Ensure `chopupInstance.cleanup()` is always called and logged.

**Verification:**
- Run `pnpm test test/integration/input-tests/single-char.test.ts` and confirm all cases pass in <5s, with logs for each step.
- Check logs for input, output, and cleanup for each test case.

---

## Commit 4: fix: Tackle text-entry.test.ts - minimize polling and log all events
**Description:**
Reduce all polling intervals and timeouts in `text-entry.test.ts` to 100ms/1s. Add logs before/after each input send, output poll, and cleanup. Ensure all test cases (normal, empty, spaces) log the input, output, and cleanup. Fail immediately if output is not as expected within 1s. Ensure all dummy scripts log when they receive input and write output.

**Verification:**
- Run `pnpm test test/integration/input-tests/text-entry.test.ts` and confirm all cases pass in <5s, with logs for each step.
- Check logs for input, output, and cleanup for each test case.

---

## Commit 5: chore: Refactor input-helpers and scripts for minimal waits and maximum observability
**Description:**
Update `test/integration/test-utils/input-helpers.ts` to use 5s timeouts for all process/socket waits, and 100ms for all polling. Add logs before/after every async wait, process spawn, and cleanup. Update all dummy scripts in `fixtures/scripts/` to log at start, on input, and on exit. Remove any unnecessary waits or delays in scripts and helpers.

**Verification:**
- Run `pnpm test test/integration/input-tests/` and confirm all tests pass in <15s total, with logs for every major event.
- Manually inspect logs for prompt, input, output, and cleanup events in all scripts and helpers.

---
</file>

<file path="release.config.js">
module.exports = {
	branches: ["main"],
	plugins: [
		["@semantic-release/commit-analyzer", { preset: "conventionalcommits" }],
		[
			"@semantic-release/release-notes-generator",
			{ preset: "conventionalcommits" },
		],
		["@semantic-release/changelog", { changelogFile: "CHANGELOG.md" }],
		["@semantic-release/npm", { npmPublish: true }],
		[
			"@semantic-release/git",
			{
				assets: ["package.json", "CHANGELOG.md"],
				message:
					"chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}",
			},
		],
	],
	verbose: true,
};
</file>

<file path=".cursor/rules/_global.mdc">
---
description: 
globs: 
alwaysApply: true
---
You are an aggressively proactive developer who forges ahead with you best ideas until a task is 100% complete and verified.
You never ask for help. Instead, you pause to think deeply, then continue with your new plan.
You expect to be interrupted if the task needs to change, otherwise FINISH THE TASK!
You speak in extremely brief sentences that:
- explain the next step
- explain before/after changes
- explain why succeed/fail

Avoid telling me: "Proceeding to next step", just start on the next step!!!

## Guiding Principles
1. Observability: add excessive logging
2. Small files: limit files to 200 lines
3. Micro-milestones: perform work in commit-sized chunks. Optimize for rewinding.

## Package Managers
Default to `pnpm` unless otherwise specified

## Preferred Libraries
- Testing: `vitest`
- Formatting/Linting: `@biomejs/biome`
- Running TypeScript: `tsx`

## Running Terminal Commands
**Important:** Avoid newline characters within single arguments or strings passed to the terminal tool, as they can cause parsing issues.

## Git
- Always use fix/feat/chore commit messages
- AVOID --no-verify
- Never push a failing test to the repo

## Project and Config Initialization
Use popular CLIs for creating projects and configurations whenever possible.

Examples: 
- pnpm init
- pnpm dlx shadcn@latest add table accordion tabs separator
- pnpm --package=typescript dlx tsc --init
- pnpm create cloudflare@latest . --framework=next --platform=pages
</file>

<file path=".cursor/rules/cli-github-search.mdc">
---
description:
globs:
alwaysApply: false
---
Usage: ghx [options]

Commands:
  ghx config      Manage configuration settings
  ghx [query]     Search GitHub Code                                   [default]

Positionals:
  query  Search query                                                   [string]

Options:
      --version       Show version number                              [boolean]
  -h, --help          Show help                                        [boolean]
  -p, --pipe          Output results directly to stdout                [boolean]
  -d, --debug         Output code fence contents for testing           [boolean]
  -L, --limit         Maximum number of results to fetch  [number] [default: 50]
  -f, --max-filename  Maximum length of generated filenames
                                                          [number] [default: 50]
  -c, --context       Number of context lines around matches
                                                          [number] [default: 20]
  -r, --repo          Search in a specific repository (owner/repo)      [string]
  -P, --path          Search in a specific path                         [string]
  -l, --language      Search for files in a specific language           [string]
  -e, --extension     Search for files with a specific extension        [string]
  -n, --filename      Search for files with a specific name             [string]
  -s, --size          Search for files of a specific size               [string]
  -F, --fork          Include or exclude forked repositories           [boolean]

Examples:
  ghx 'useState'                            Search for 'useState' across all ind
                                            exed code on GitHub
  ghx --repo facebook/react "useState"      Search for 'useState' in the faceboo
                                            k/react repository
  ghx -l typescript -e tsx "useState"       Search for 'useState' in TypeScript
                                            files with the .tsx extension
  ghx -n package.json "dependencies"        Search for 'dependencies' specifical
                                            ly within package.json files
  ghx -P src/components "Button"            Search for 'Button' within the src/c
                                            omponents path
  ghx -s '">10000" -l go "package main"     Search for 'package main' in Go file
                                            s larger than 10KB
  ghx "async function" -l typescript        Search for the exact phrase 'async f
                                            unction' in TypeScript files
  ghx "my search terms" --pipe > results.m  Search and pipe the results directly
  d                                          to a markdown file
  ghx -L 100 -c 30 "complex query"          Fetch up to 100 results with 30 line
                                            s of context per match
  ghx -l typescript "import test"           Search for lines containing both 'im
                                            port' AND 'test' in TypeScript files
  ghx -l javascript "const OR let"          Search for lines containing either '
                                            const' OR 'let' in JavaScript files
  ghx -l css "color NOT background-color"   Search for lines containing 'color'
                                            BUT NOT 'background-color' in CSS fi
                                            les
</file>

<file path=".cursor/rules/cli-pack.mdc">
---
description:
globs:
alwaysApply: false
---
Your goal is to pack up files into a single file using the `repomix` cli.

## Defaults
- Always use `-o tmp/<filename>` so that the file is saved to a `tmp/` directory within the current project.
- Always ignore "tmp"
- Always include token count: use `--token-count-encoding o200k_base`
- Never include line numbers: do NOT use `--output-show-line-numbers`
- Include ".cursor/rules/_project.mdc", but ignore other ".cursor/rules" files

## Usage
Usage: repomix [options] [directories...]

Repomix - Pack your repository into a single AI-friendly file

Arguments:
  directories                        list of directories to process (default: ["."])

Options:
  -v, --version                      show version information
  -o, --output <file>                specify the output file name
  --style <type>                     specify the output style (xml, markdown, plain)
  --parsable-style                   ensure output is parsable as its type
  --compress                         perform code compression to reduce token count
  --output-show-line-numbers         add line numbers to each line in the output
  --copy                             copy generated output to system clipboard
  --no-file-summary                  disable file summary section output
  --no-directory-structure           disable directory structure section output
  --no-files                         disable files content output (metadata-only mode)
  --remove-comments                  remove comments
  --remove-empty-lines               remove empty lines
  --header-text <text>               specify the header text
  --instruction-file-path <path>     path to a file containing detailed custom instructions
  --include-empty-directories        include empty directories in the output
  --no-git-sort-by-changes           disable sorting files by git change count
  --include <patterns>               list of include patterns (comma-separated)
  -i, --ignore <patterns>            additional ignore patterns (comma-separated)
  --no-gitignore                     disable .gitignore file usage
  --no-default-patterns              disable default patterns
  --remote <url>                     process a remote Git repository
  --remote-branch <name>             specify the remote branch name, tag, or commit hash
  -c, --config <path>                path to a custom config file
  --init                             initialize a new repomix.config.json file
  --global                           use global configuration (only with --init)
  --no-security-check                disable security check
  --token-count-encoding <encoding>  specify token count encoding (e.g., o200k_base, cl100k_base)
  --mcp                              run as a MCP server
  --top-files-len <number>           number of top files to display
  --verbose                          enable verbose logging for detailed output
  --quiet                            disable all output to stdout
  -h, --help                         display help for command

## Output Formats
- Default: plain text
- Markdown: `--style markdown`
- XML: `--style xml`

## Security
- By default, security checks are enabled. Use `--no-security-check` to disable.

## Configuration
- Initialize config: `repomix --init`
- Use custom config: `-c repomix.config.json`
- Use global config: `--global` (with --init)

## Advanced Features
- Remove comments: `--remove-comments`
- Remove empty lines: `--remove-empty-lines`
- Show line numbers: `--output-show-line-numbers`
- Copy output to clipboard: `--copy`
- Token counting: `--token-count-encoding o200k_base`
- Disable file summary: `--no-file-summary`
- Disable directory structure: `--no-directory-structure`
- Metadata only: `--no-files`
- Include only certain files: `--include "src/**/*.ts,**/*.md"`
- Exclude files: `--ignore "**/*.log,tmp/"`
- Process remote repo: `--remote user/repo --remote-branch main`

## Model-Specific Tips
- Claude: Use XML output, put important instructions at the end
- ChatGPT: Use Markdown, break large codebases into sections
- Gemini: All formats supported, focus on specific areas per request

## Example Commands
# Basic usage
repomix

# Custom output
repomix -o tmp/output.xml --style xml

# Markdown output, compressed, no comments
repomix -o tmp/output.md --style markdown --compress --remove-comments

# Only include TypeScript and Markdown files, ignore tests
repomix --include "src/**/*.ts,**/*.md" --ignore "**/*.test.ts" -o tmp/filtered.md

# Show line numbers, copy to clipboard
repomix --output-show-line-numbers --copy -o tmp/numbered.txt

# Remote repository (GitHub URL)
repomix --remote https://github.com/user/repo --remote-branch main -o tmp/remote.txt

# Initialize config file
repomix --init

# Use custom config
repomix -c repomix.config.json -o tmp/custom.txt


## Post-Processing
- After running repomix, always inspect the reported token count.
- If the token count exceeds 500,000 tokens:
  - Suggest a more aggressive pack by ignoring large or non-essential directories/files.
  - Example: `repomix --ignore "node_modules/,dist/,build/,public/,docs/,**/*.png,**/*.jpg" -o tmp/packed-smaller.md --token-count-encoding o200k_base`
- Review the output and repeat until the token count is manageable for your target LLM.
</file>

<file path=".cursor/rules/cli-wrangler.mdc">
---
description:
globs:
alwaysApply: false
---
# Wrangler CLI Documentation (Generated from Actual CLI Output)

## Top-Level Commands

- `wrangler docs [search..]` — Open Wrangler's command documentation in your browser
- `wrangler init [name]` — Initialize a basic Worker
- `wrangler dev [script]` — Start a local server for developing your Worker
- `wrangler deploy [script]` — Deploy a Worker to Cloudflare
- `wrangler deployments` — List and view current and past deployments
- `wrangler rollback [version-id]` — Rollback a deployment
- `wrangler versions` — List, view, upload, and deploy Worker versions
- `wrangler triggers` — Update deployment triggers [experimental]
- `wrangler delete [script]` — Delete a Worker from Cloudflare
- `wrangler tail [worker]` — Start a log tailing session for a Worker
- `wrangler secret` — Generate a secret for a Worker
- `wrangler types [path]` — Generate types from Worker configuration

### Resource Management

- `wrangler kv` — Manage Workers KV Namespaces
- `wrangler queues` — Manage Workers Queues
- `wrangler r2` — Manage R2 buckets & objects
- `wrangler d1` — Manage Workers D1 databases
- `wrangler vectorize` — Manage Vectorize indexes
- `wrangler hyperdrive` — Manage Hyperdrive databases
- `wrangler cert` — Manage client mTLS certificates and CA certificate chains [open-beta]
- `wrangler pages` — Configure Cloudflare Pages
- `wrangler mtls-certificate` — Manage certificates for mTLS connections
- `wrangler pubsub` — Manage Pub/Sub brokers [private beta]
- `wrangler dispatch-namespace` — Manage dispatch namespaces
- `wrangler ai` — Manage AI models
- `wrangler workflows` — Manage Workflows
- `wrangler pipelines` — Manage Cloudflare Pipelines [open-beta]
- `wrangler login` — Login to Cloudflare
- `wrangler logout` — Logout from Cloudflare
- `wrangler whoami` — Retrieve user information
- `wrangler secrets-store` — Manage the Secrets Store [alpha]

---

## Global Flags

- `-c, --config <file>` — Path to Wrangler configuration file
- `--cwd <dir>` — Run as if Wrangler was started in the specified directory
- `-e, --env <env>` — Environment to use for operations and for selecting .env/.dev.vars files
- `-h, --help` — Show help
- `-v, --version` — Show version number

---

## Example Subcommand Trees

### wrangler kv

- `namespace`
  - `create <namespace>`
  - `list`
  - `delete`
- `key`
  - `put <key> [value]`
  - `list`
  - `get <key>`
  - `delete <key>`
- `bulk`
  - `get <filename>`
  - `put <filename>`
  - `delete <filename>`

### wrangler queues

- `list`
- `create <name>`
- `update <name>`
- `delete <name>`
- `info <name>`
- `consumer`
- `pause-delivery <name>`
- `resume-delivery <name>`
- `purge <name>`

### wrangler r2

- `object`
  - `get <objectPath>`
  - `put <objectPath>`
  - `delete <objectPath>`
- `bucket`
  - `create <name>`
  - `update`
  - `list`
  - `info <bucket>`
  - `delete <bucket>`
  - `sippy`
  - `catalog`
  - `notification`
  - `domain`
  - `dev-url`
  - `lifecycle`
  - `cors`
  - `lock`

### wrangler d1

- `list`
- `info <name>`
- `insights <name>`
- `create <name>`
- `delete <name>`
- `execute <database>`
- `export <name>`
- `time-travel`
- `migrations`

### wrangler vectorize

- `create <name>`
- `delete <name>`
- `get <name>`
- `list`
- `query <name>`
- `insert <name>`
- `upsert <name>`
- `get-vectors <name>`
- `delete-vectors <name>`
- `info <name>`
- `create-metadata-index <name>`
- `list-metadata-index <name>`
- `delete-metadata-index <name>`

### wrangler hyperdrive

- `create <name>`
- `delete <id>`
- `get <id>`
- `list`
- `update <id>`

### wrangler cert

- `upload`
- `list`
- `delete`

### wrangler pages

- `dev [directory] [command]`
- `functions`
- `project`
- `deployment`
- `deploy [directory]`
- `secret`
- `download`

### wrangler mtls-certificate

- `upload`
- `list`
- `delete`

### wrangler pubsub

- `namespace`
- `broker`

### wrangler dispatch-namespace

- `list`
- `get <name>`
- `create <name>`
- `delete <name>`
- `rename <oldName> <newName>`

### wrangler ai

- `models`
- `finetune`

### wrangler workflows

- `list`
- `describe <name>`
- `trigger <name> [params]`
- `instances`

### wrangler pipelines

- `create <pipeline>`
- `list`
- `get <pipeline>`
- `update <pipeline>`
- `delete <pipeline>`

---

This documentation is generated from actual Wrangler CLI output and is up-to-date as of the time of generation. For more details on any subcommand, run `wrangler <subcommand> --help`.
</file>

<file path=".cursor/rules/docs-diagram.mdc">
---
description:
globs:
alwaysApply: false
---
Attempt to read `NOTES.md`, `docs/PRD.md`, `docs/TECH_STACK.md`, and `openapi.yaml` before starting.

Create all diagrams in `docs/diagrams/<diagram>.md`


Here are the essential rules for creating Mermaid diagrams that render well in GitHub Markdown:


1.  **Use the Correct Fenced Code Block:**

    - Always start the block with ` ```mermaid ` and end it with ` ``` `.

    - ```markdown

        ```mermaid

          graph TD

            A[Start] --> B{Decision};

            B -- Yes --> C[Action 1];

            B -- No --> D[Action 2];

        ```

        ```


2.  **Stick to Well-Supported Diagram Types:**

    - GitHub generally has good support for the most common types:

        - `graph` (Flowcharts - `TD` is often best for readability)

        - `sequenceDiagram`

        - `classDiagram`

        - `stateDiagram-v2` (Prefer v2 for better features/rendering)

        - `erDiagram` (Entity Relationship)

        - `pie` (Pie charts)

        - `gantt` (Gantt charts)

        - `mindmap` (Mind Maps - Basic structure only. *See syntax notes below*)

    - Avoid extremely new or less common diagram types, as GitHub's Mermaid version might lag slightly behind the latest release.


3.  **Keep Syntax Simple and Standard:**

    - **Node IDs:** Use simple alphanumeric IDs (e.g., `node1`, `processA`, `userAuth`). Avoid spaces or special characters in IDs.

    - **Node/Actor/State Labels:** **Use quotes (`"..."`)** for labels, especially if they contain spaces, punctuation, special characters, or Mermaid keywords. This is the most common source of rendering errors.

        - *Good:* `A["User Input"] --> B["Validate Data"];`

        - *Bad (potential error):* `A[User Input] --> B[Validate Data];`

    - **Arrows:** Use standard arrow types (`-->`, `---`, `==>`, `->>`, etc.).

    - **Comments:** Use `%%` for comments if needed.


4.  **Mindmap Specifics for GitHub:**

    - GitHub **supports the basic `mindmap` structure**, using indentation to define hierarchy (parent/child relationships).

    - Ensure each node/item is on its **own line** with correct indentation relative to its parent.

    - GitHub **DOES NOT support** experimental or advanced `mindmap` features like `::icon()` syntax. Using icons **will cause rendering errors**.

    - Stick to plain text nodes for mind maps intended for GitHub Markdown.

    - *Correct Example (GitHub compatible):*

        ```mermaid

        mindmap

          Root

            Parent

              Child 1

              Child 2

        ```

    - *Incorrect Example (GitHub incompatible due to icons):*

        ```mermaid

        mindmap

          Root

            Parent

              ::icon(fa fa-one) Child 1

              ::icon(fa fa-two) Child 2

        ```


5.  **Prefer Vertical Layouts (`graph TD`):**

    - For flowcharts (`graph`), `TD` (Top Down) or `TB` (Top Bottom) usually renders more readably within the flow of a Markdown document than `LR` (Left Right). GitHub often gives diagrams ample width, but vertical flows are easier to follow on typical screens.


6.  **Let GitHub Handle the Styling:**

    - **DO NOT** try to set themes (e.g., `%%{init: {'theme': 'dark'}}%%`) or apply custom styling using `classDef` or `style` *within the Mermaid code*.

    - GitHub **ignores** these theme directives and applies its own styling based on whether the user is viewing GitHub in light, dark, or dimmed mode. Your diagram will automatically adapt. Trying to force colors or themes will likely just be ignored or look out of place.


7.  **Keep Diagrams Focused:**

    - Avoid overly complex diagrams with excessive nodes, edges, or nesting in a single block. While GitHub *can* render complex ones, they might become hard to read or hit rendering limits. Break down very complex ideas into multiple simpler diagrams if possible.


8.  **Test in GitHub Preview:**

    - Always use GitHub's preview tab when editing your Markdown file to see exactly how the diagram will render. This is the best way to catch syntax errors or unexpected layout issues.


9.  **Tooling & Edit Verification Note:**

    - Automated code editing tools may sometimes struggle to apply changes correctly within Mermaid blocks, especially with complex syntax involving indentation or specific formatting (like the mindmap example above).

    - **Always carefully review edits** made to Mermaid blocks by automated tools. If errors persist or the diagram doesn't render as expected, manual correction might be necessary.


**In short:** Write standard, clearly quoted Mermaid syntax using common diagram types. For mindmaps in GitHub, use only the basic indentation structure (no icons). Prefer `graph TD`. Avoid trying to control the theme/colors yourself. Use the GitHub preview, and double-check automated edits to Mermaid blocks.
</file>

<file path=".cursor/rules/docs-openapi-spec.mdc">
---
description:
globs:
alwaysApply: false
---
## OpenAPI Specification Management Rule

*This rule guides the creation and maintenance of the `docs/openapi.yaml` file.*

### Core Directive
Create and maintain an `docs/openapi.yaml` file, defining an OpenAPI specification (v3.0.x or 3.1.x). Operate based on information from `NOTES.md`, `docs/PRD.md`, `docs/TECH_STACK.md`, and the existing `docs/openapi.yaml` (if present), ensuring adherence to the OpenAPI structure outlined below.

### Strict Limitations
* **File Operations:** Only read `NOTES.md`, `docs/PRD.md`, `docs/TECH_STACK.md`, `docs/openapi.yaml` (or equivalents), and read/write to `docs/openapi.yaml`. Do not interact with other files.
* **Output Format:** Your entire output must be the content of the `docs/openapi.yaml` file itself.
* **Communication:** You are forbidden from generating any conversational output, commentary, preamble, or summaries outside of the `docs/openapi.yaml` file.
* **User Interaction (within `docs/openapi.yaml`):** You do not directly converse with the user. If sections of the `docs/openapi.yaml` are incomplete or require clarification, you will indicate this *within the `docs/openapi.yaml` file* using a specific YAML comment format.

### OpenAPI Specification Structure and Content Source
The `docs/openapi.yaml` file must follow the structure below, derived from the "OpenAPI Specification Outline" questions. Aim for OpenAPI version 3.0.x or 3.1.x.

#### OpenAPI Specification Outline (Source for `docs/openapi.yaml` Structure and TODOs)

1.  **OpenAPI Version & Basic Information (`openapi`, `info` block):**
    * Specify the OpenAPI version (e.g., `openapi: 3.0.3`).
    * **Title (`info.title`):** What is the official title for this API? (Source: `docs/PRD.md` - Project Name/Title. Example: "Customer Data API").
    * **Version (`info.version`):** What is the current version of this API specification (e.g., "1.0.0", "v2.1-beta")?
    * **Description (`info.description`):** Provide a brief description of the API's purpose and capabilities. (Source: `docs/PRD.md` - Project Purpose/Core Functionality. Example: "API for managing customer profiles and order history.").
    * **(Optional) Contact (`info.contact`):**
        * `name`: Contact person/team name (e.g., "API Support Team").
        * `url`: URL to a support page or contact form.
        * `email`: Contact email address (e.g., "apisupport@example.com").
    * **(Optional) License (`info.license`):**
        * `name`: SPDX license identifier (e.g., "Apache 2.0", "MIT").
        * `url`: Link to the full license text.

2.  **Server Configuration (`servers` block):**
    * What are the base URLs for accessing the API? (Source: `docs/TECH_STACK.md` - Infrastructure & Deployment. Examples: `https://api.example.com/v1`, `https://sandbox.api.example.com/v1`).
    * For each server, provide:
        * `url`: The server URL.
        * `description`: A human-readable description (e.g., "Production Server", "Sandbox Environment").

3.  **Global Security Definitions (`components.securitySchemes` & `security` block):**
    * What authentication/authorization methods will this API use? (Source: `docs/TECH_STACK.md` - Security Considerations. Examples: API Key, OAuth2, JWT Bearer Token).
    * Define each scheme under `components.securitySchemes`:
        * **API Key Example (`apiKeyAuth`):**
            * `type: apiKey`
            * `in: header` (or `query`, `cookie`)
            * `name: X-API-KEY` (the name of the header or query parameter)
        * **OAuth2 Example (`oauth2Auth`):**
            * `type: oauth2`
            * `flows`: Define one or more flows (e.g., `authorizationCode`, `clientCredentials`).
                * `authorizationCode`:
                    * `authorizationUrl: https://auth.example.com/oauth/authorize`
                    * `tokenUrl: https://auth.example.com/oauth/token`
                    * `scopes`: Define available scopes (e.g., `read:profile`, `write:orders`).
    * If security applies globally to most/all endpoints, define it under the top-level `security` block. (Example: `security: - apiKeyAuth: []`).

4.  **Tags for Grouping Operations (`tags` block):**
    * What are the main functional groupings or resource categories for your API endpoints? (Source: `docs/PRD.md` - Key Features/Modules. Examples: "Users", "Products", "Orders").
    * For each tag, provide:
        * `name`: The tag name (e.g., "UserManagement").
        * `description`: A brief explanation of the tag (e.g., "Operations related to user accounts and profiles").

5.  **Reusable Schemas (`components.schemas` block):**
    * What are the common data models (objects) that will be used in request and response bodies? (Source: `docs/PRD.md` - Key Features, Data Models; `docs/TECH_STACK.md` - Database for entities. Examples: `User`, `Product`, `Order`, `ErrorResponse`).
    * For each schema (e.g., `User`):
        * `type: object`
        * `properties`: Define its fields.
            * For each property (e.g., `id`, `username`,
</file>

<file path=".cursor/rules/docs-prd.mdc">
---
description:
globs:
alwaysApply: false
---
## PRD Management Rule

*This rule guides the creation and maintenance of the `docs/PRD.md` file.*

### Core Directive
Create, maintain, and update the `docs/PRD.md` file located in the root of the project. Operate based on information found in `NOTES.md` and ensure `docs/PRD.md` aligns with the predefined structure below.

### Strict Limitations
* **File Operations:** You are ONLY permitted to read `NOTES.md` and read/write to `docs/PRD.md`. You must not interact with any other files or perform any other actions.
* **Communication:** You are forbidden from generating any conversational output, commentary, preamble, or summaries. Your entire output must be the content of the `docs/PRD.md` file itself. Do not repeat the contents of `docs/PRD.md` back to the user in any other format.
* **User Interaction:** You do not directly converse with the user. If sections of the `docs/PRD.md` are incomplete, you will indicate this *within* the `docs/PRD.md` file using a specific comment format.

### PRD Structure and Content Source
The `docs/PRD.md` file must be structured around the following eight key sections, derived from the "Technical Plan Outline" questions below.

#### Technical Plan Outline (Source for docs/PRD.md Structure and TODOs)

1.  **Core Functionality & Purpose:**
    * Primary problem solved for the end-user.
    * Core functionality required.
2.  **Key Technical Goals & Scope:**
    * Critical technical objectives (e.g., performance benchmarks, integrations, tech stack).
    * Explicitly out-of-scope items for the current development cycle.
3.  **User Interaction & Technical Design:**
    * Primary user type (e.g., API consumer, web app user).
    * Interaction methods with core features (reference UI mockups, API contracts, user flows if available in `NOTES.md`).
4.  **Essential Features & Implementation Details:**
    * Absolute must-have functionalities for the initial version.
    * High-level implementation considerations for each feature.
5.  **Acceptance Criteria & "Done" Definition:**
    * Specific, testable conditions for each key feature/user story to define "done."
6.  **Key Technical Requirements & Constraints:**
    * Non-negotiable technical requirements (e.g., target platform, languages, frameworks, integrations).
    * Non-functional requirements (e.g., performance targets, scalability, security, reliability) and constraints (e.g., infrastructure, budget).
7.  **Success Metrics (Technical Viewpoint):**
    * How the development team will measure technical success post-deployment (e.g., system stability, error rates, performance metrics).
8.  **Development Logistics & Lookahead:**
    * Significant technical risks or dependencies and initial mitigation thoughts.
    * Major assumptions that could derail development if incorrect.
    * Future development considerations for current design (e.g., extensibility).

### Workflow

1.  **Process User Request:** A user request triggers your operation. (This prompt assumes the trigger is an implicit instruction to update/create the PRD).
2.  **Access Files:**
    * Read the content of `NOTES.md`. This is your primary source of information for populating `docs/PRD.md`.
    * Read the current content of `docs/PRD.md` if it exists.
3.  **Manage `docs/PRD.md`:**
    * **Initialization:** If `docs/PRD.md` does not exist, create it. Populate it with the eight section headers listed above.
    * **Content Integration:** For each of the eight sections in `docs/PRD.md`:
        * Review `NOTES.md` for relevant information pertaining to that section.
        * Update the corresponding section in `docs/PRD.md` with this information. If the section already has content, intelligently merge or update it based on the latest `NOTES.md`. Strive to be comprehensive but concise.
    * **Identify Gaps & Insert TODOs:** After attempting to populate each section from `NOTES.md`:
        - A TODO comment MUST ONLY be inserted if, after reviewing `NOTES.md`, the section in `docs/PRD.md` remains genuinely empty, or contains only placeholder text (e.g., a rephrasing of the section title without substantive information), or if critical information explicitly requested by the section's definition (as outlined in "Technical Plan Outline") is clearly missing and not found in `NOTES.md`.
        - Do NOT insert a TODO comment if the section has been populated with relevant information from `NOTES.md`, even if that information could be more detailed. The purpose of the TODO is to address missing information, not to solicit further elaboration on existing information unless that information is so scant as to be effectively missing or fails to address the core requirements of the section.
        - **TODO Comment Format:** Use an HTML comment starting with `<!-- TODO: ... -->`.
        - **Contextual TODO Prompts:** When a TODO is necessary according to the criteria above, analyze `NOTES.md` and the current `docs/PRD.md` to infer a specific question that addresses the missing information. The examples provided in "Technical Plan Outline" for each section should be used as inspiration for formulating these contextual prompts. The goal is to ask targeted questions based on the current context, rather than always using the generic examples, to guide the user in providing the specific missing information.

4.  **Output:** Your final action is to output the complete, updated content of `docs/PRD.md`. No other text or explanation should be provided.

### Final Instruction
Execute these instructions precisely. Your sole focus is the `docs/PRD.md` file.
</file>

<file path=".cursor/rules/docs-structure.mdc">
---
description:
globs:
alwaysApply: false
---
# You Mock Out Project File Structure

- Read all the files in docs/*
- Print the best practices for the project structure

Write them to docs/STRUCTURE.md
</file>

<file path=".cursor/rules/docs-sync.mdc">
---
description:
globs:
alwaysApply: false
---
# Documentation Synchronization Guide

- Read through all files in `docs/`.
- Review completed tasks (e.g., in `docs/tasks/` or commit history).
- Update any documentation (`docs/*`) that appears out-of-date based on the completed work.
</file>

<file path=".cursor/rules/docs-tech-stack.mdc">
---
description:
globs:
alwaysApply: false
---
# Tech Stack Management Rule

*This rule guides the creation and maintenance of the `docs/TECH_STACK.md` file.*

### Core Directive
Create, maintain, and update the `docs/TECH_STACK.md` file based on information found in `NOTES.md`, `docs/PRD.md`, and `docs/openapi.yaml` (or similar), ensuring alignment with the predefined structure below.

### Strict Limitations
* **File Operations:** Only read `NOTES.md`, `docs/PRD.md`, `docs/openapi.yaml` (or equivalents), and read/write to `docs/TECH_STACK.md`. Do not interact with other files.
* **Communication:** You are forbidden from generating any conversational output, commentary, preamble, or summaries. Your entire output must be the content of the `docs/TECH_STACK.md` file itself. Do not repeat the contents of `docs/TECH_STACK.md` back to the user in any other format.
* **User Interaction:** You do not directly converse with the user. If sections of the `docs/TECH_STACK.md` are incomplete, you will indicate this *within* the `docs/TECH_STACK.md` file using a specific comment format.

### Tech Stack Definition Structure and Content Source
The `docs/TECH_STACK.md` file must be structured around the following key sections. These sections are derived from the "Tech Stack Definition Outline" questions.

#### Tech Stack Definition Outline (Source for docs/TECH_STACK.md Structure and TODOs)

1.  **Project Overview & Goals (Informed by PRD):**
    * Briefly, what is the project this tech stack is for? (Reference `docs/PRD.md` for project description and goals).
    * What are the primary goals influencing technology choices (e.g., scalability, speed of development, specific integrations, team expertise, budget)? (Reference `docs/PRD.md` for technical goals and constraints).
2.  **Core Languages & Runtimes:**
    * What primary programming language(s) will be used for the backend? Specify version(s) if critical. Why this choice?
    * What primary programming language(s) and/or frameworks will be used for the frontend? Specify version(s) if critical. Why this choice?
    * Are there specific runtime environments required (e.g., Node.js version, Python version, JVM version, .NET version)?
3.  **Frameworks & Libraries (Backend):**
    * What backend frameworks are being chosen or considered (e.g., Django, Ruby on Rails, Spring Boot, Express.js, NestJS, ASP.NET Core)? Justify the choice.
    * List key libraries essential for the backend (e.g., ORM/database interaction, authentication/authorization, caching, background job processing, API documentation generation).
4.  **Frameworks & Libraries (Frontend):**
    * What frontend frameworks/libraries are being chosen or considered (e.g., React, Angular, Vue, Svelte, Blazor)? Justify the choice.
    * List key UI component libraries (e.g., Material UI, Bootstrap, Tailwind CSS, Ant Design) or state management solutions (e.g., Redux, Zustand, Pinia, NgRx) to be used.
5.  **Database & Data Storage:**
    * What type of database is required (e.g., Relational/SQL, NoSQL Document, NoSQL Key-Value, Graph, Time Series)? Why? (Consider data types and relationships outlined in `docs/PRD.md`).
    * Specify the chosen database system(s) (e.g., PostgreSQL, MySQL, MongoDB, Cassandra, Neo4j, InfluxDB).
    * Are other data storage solutions needed (e.g., caching like Redis/Memcached, object storage like AWS S3/Google Cloud Storage, message queues like RabbitMQ/Kafka)?
6.  **Infrastructure & Deployment:**
    * Where will the application be hosted (e.g., AWS, Azure, GCP, DigitalOcean, Vercel, Netlify, on-premise)?
    * What specific services will be used (e.g., EC2, Lambda, Azure App Service, Google Kubernetes Engine)?
    * What containerization technologies will be used (e.g., Docker, Podman)? Orchestration (e.g., Kubernetes, Docker Swarm)?
    * What CI/CD tools and processes are planned (e.g., Jenkins, GitLab CI, GitHub Actions, CircleCI)?
7.  **APIs & Integrations:**
    * Will the project expose its own APIs? If so, what style (e.g., REST, GraphQL, gRPC, WebSockets)? (Reference `docs/PRD.md` and `docs/openapi.yaml` for API requirements if any).
    * What critical third-party services or APIs will be integrated (e.g., payment gateways like Stripe/PayPal, identity providers like Auth0/Okta, analytics services, communication services like Twilio/SendGrid)? (Reference `docs/PRD.md` for known integrations).
8.  **Development Tools & Standards:**
    * What version control system will be used (e.g., Git)? Where will repositories be hosted (e.g., GitHub, GitLab, Bitbucket)?
    * Are there specific IDEs, linters (e.g., ESLint, Pylint), or code formatting standards (e.g., Prettier, Black)?
    * What testing frameworks and strategies will be employed (e.g., Jest, PyTest, JUnit, Cypress, Selenium; unit, integration, E2E testing)? (Reference `docs/PRD.md` for acceptance criteria).
9.  **Security Considerations:**
    * What are the key security requirements for the chosen technologies (e.g., OWASP Top 10 mitigations)? (Reference `docs/PRD.md` for security requirements).
    * Are there specific libraries, tools, or practices for security (e.g., for authentication, authorization, input validation, data encryption, dependency scanning, secrets management)?
10. **Rationale & Alternatives Considered:**
    * For major technology choices (especially languages, frameworks, databases, hosting), briefly explain the rationale and any significant alternatives that were considered and why they were not chosen.

### Workflow

1.  **Process User Request:** A user request triggers your operation. (This prompt assumes the trigger is an implicit instruction to update/create the `docs/TECH_STACK.md`).
2.  **Access Files:**
    * Read the content of `NOTES.md` (or the specified input file).
    * Read the content of `docs/PRD.md` (or the specified input file).
    * Read the content of `docs/openapi.yaml` (or the specified input file) if it exists.
    * These files are your primary sources of information for populating `docs/TECH_STACK.md`.
    * Read the current content of `docs/TECH_STACK.md` if it exists.
3.  **Manage `docs/TECH_STACK.md`:**
    * **Initialization:** If `docs/TECH_STACK.md` does not exist, create it. Populate it with the ten section headers listed above.
    * **Content Integration:** For each of the ten sections in `docs/TECH_STACK.md`:
        * Review `NOTES.md`, `docs/PRD.md`, and `docs/openapi.yaml` for relevant information pertaining to that section. Note that some outline points specifically suggest referencing `docs/PRD.md` or `docs/openapi.yaml`.
        * Update the corresponding section in `docs/TECH_STACK.md` with this information. If the section already has content, intelligently merge or update it based on the latest information from all source files. Strive to be comprehensive but concise.
    * **Identify Gaps & Insert TODOs:** After attempting to populate each section from `NOTES.md`, `docs/PRD.md`, and `docs/openapi.yaml`:
        - A TODO comment MUST ONLY be inserted if, after reviewing `NOTES.md`, `docs/PRD.md`, and `docs/openapi.yaml`, the section in `docs/TECH_STACK.md` remains genuinely empty, or contains only placeholder text (e.g., a rephrasing of the section title without substantive information), or if critical information explicitly requested by the section's definition (as outlined in "Tech Stack Definition Outline") is clearly missing and not found in the source files.
        - Do NOT insert a TODO comment if the section has been populated with relevant information from the source files, even if that information could be more detailed. The purpose of the TODO is to address missing information, not to solicit further elaboration on existing information unless that information is so scant as to be effectively missing or fails to address the core requirements of the section.
        - **TODO Comment Format:** Use an HTML comment starting with `<!-- TODO: ... -->`. (This aligns the format with the `prd` rule for consistency and allows the guiding question to be embedded within the comment, which supports the goal stated in "Contextual TODO Prompts".)
        - **Contextual TODO Prompts:** The primary goal of the TODO comment, when necessary according to the criteria above, is to clearly state what information is missing by asking the relevant question. Provide helpful examples (either from the outline point itself or generated if the outline point lacks them) to elicit the required details. Formulate targeted questions based on the current context and the specific missing information.

4.  **Output:** Your final action is to output the complete, updated content of `docs/TECH_STACK.md`. No other text or explanation should be provided.

### Final Instruction
Execute these instructions precisely. Your sole focus is the `docs/TECH_STACK.md` file.
</file>

<file path=".cursor/rules/pnpm-fixes.mdc">
---
description:
globs:
alwaysApply: false
---
## Allow Running Scripts for Popular Libraries

For example (in `package.json`):

  "pnpm": {
    "onlyBuiltDependencies": [
      "sqlite3"
    ]
  }
- https://pnpm.io/settings#onlybuiltdependencies

Or:
* Use `pnpm install --dangerously-allow-all-builds` when installing popular libraries.
- https://pnpm.io/settings#dangerouslyallowallbuilds
</file>

<file path=".cursor/rules/project-todos-next.mdc">
---
description:
globs:
alwaysApply: false
---
# Surface TODOs from Documentation

- Search all files within the `docs/` directory for comments containing "TODO".
- List the most pressing or relevant TODOs found.
</file>

<file path=".cursor/rules/project-update-rules.mdc">
---
description:
globs:
alwaysApply: false
---
# .cursor/rules/_project.mdc manager

## Core Directive

Update .cursor/rules/_project.mdc based on project's configuration and docs

## Task

Gather project information about configuration, libraries:
- list all files in the project root and read the files relevant to configuration
- read all files in docs

Read and update the following file with the information you find:
- ./cursor/rules/_project.mdc


## .cursor/rules/_project.mdc Template

Use this template as guide for creating the _project.mdc:

<template>
---
description: 
globs: 
alwaysApply: true
---

# [Project Name] - Project Rules

## 1. Project Overview

goal: [Concisely describe the main purpose and goal of the project. What problem does it solve?]
type: [e.g., Web Application, CLI Tool, Library, Mobile App, Backend API, Monorepo]
key features:
- [core functionality or feature 1]
- [core functionality or feature 2]
- [core functionality or feature 3]

## 2. Technology Stack

language(s): [e.g., TypeScript 5.x, Python 3.11, Go 1.23, Java 17]
framework(s): [e.g., Next.js 15 (App Router), React 19, FastAPI, Spring Boot, SvelteKit]
ui library/styling: [e.g., Tailwind CSS v4, Shadcn UI, Material UI, CSS Modules]
database(s): [e.g., PostgreSQL via Prisma, MongoDB, Supabase, SQLite via Drizzle]
state management: [e.g., Zustand, React Context, Redux, Pinia, None (Local State)]
api layer: [e.g., REST (via Next.js API Routes/FastAPI), GraphQL, tRPC]
key libraries:
- [critical dependency 1]
- [critical dependency 2]

## 3. Project Structure

main source directory: [e.g., src/, app/, packages/]
core directories:
- components/: Reusable UI elements
- lib/ or utils/: Shared utility functions
- services/ or api/: Business logic, API interactions
- types/: Shared type definitions
- db/ or prisma/: Database schema and access
- tests/: Test files (if not co-located)
diagram/link: [Link to an architecture diagram or provide a simple ASCII tree if helpful.]

## 4. Coding Standards & Conventions

language usage: [e.g., Prefer functional components, Use async/await, Strict TypeScript mode, Avoid any]
naming conventions:
- files/folders: [e.g., kebab-case, PascalCase]
- components: [e.g., PascalCase]
- variables/functions: [e.g., camelCase, snake_case]
- types/interfaces: [e.g., PascalCase, TPrefix]
code style/formatting: [e.g., Prettier, ESLint, Ruff, Biome - mention config file if present, e.g., .eslintrc.js]
comments: [e.g., English only, JSDoc for public APIs, Minimal comments]
imports: [e.g., Absolute paths (@/), Grouped/Sorted (stdlib, external, internal)]

## 5. Key Principles & Best Practices

- [guiding principle 1]
- [guiding principle 2]
- [guiding principle 3]

## 6. Testing

framework: [e.g., Jest, Vitest, Pytest, Go testing]
types: [e.g., Unit tests required for services, Integration tests for API endpoints, E2E with Playwright/Cypress]
location: [e.g., Co-located with source files (*.test.ts), Top-level tests/ directory]

## 7. Tooling & Workflow

package manager: [e.g., pnpm, npm, bun, yarn, poetry, uv]
build command(s): [e.g., pnpm build, make build]
run command(s): [e.g., pnpm dev, python main.py, go run ./cmd/...]
version control: [e.g., Git, Conventional Commits required, PRs to main branch]
ci/cd: [e.g., GitHub Actions - lint, test, build on PR]

## 8. (Optional) Database / API Guidelines

- [Add specific rules for DB interaction (e.g., Use ORM methods only, No direct SQL), API design (e.g., RESTful principles, Error response format), or Server Actions.]

## 9. (Optional) Specific Feature Rules

- [Add rules for specific complex parts of the application if needed, e.g., Authentication, Internationalization (i18n), State Management details.]

## 10. (Optional) Rule Referencing

- [If applicable, link to other .mdc rule files for more detailed guidelines, e.g.,
  - See [typescript.mdc](mdc:.cursor/rules/typescript.mdc) for detailed TS rules.
  - Follow guidelines in [auth.mdc](mdc:.cursor/rules/auth.mdc) for authentication.
  ]
</template>
</file>

<file path=".cursor/rules/project-worktrees.mdc">
---
description:
globs:
alwaysApply: false
---
To manage worktrees, use the `wt` cli
If it fails to run, you may need to install `https://www.npmjs.com/package/@johnlindquist/worktree` globally

Usage: wt [options] [command]

Manage git worktrees and open them in the Cursor editor.

Options:
  -V, --version                       output the version number
  -h, --help                          display help for command

Commands:
  new [options] [branchName]          Create a new worktree for the specified
                                      branch, install dependencies if
                                      specified, and open in editor.
  list|ls                             List all existing worktrees for this
                                      repository.
  remove|rm [options] [pathOrBranch]  Remove a specified worktree. Cleans up
                                      the .git/worktrees references.
  merge [options] <branchName>        Commit changes in the target branch and
                                      merge them into the current branch, then
                                      remove the branch/worktree
  purge                               Safely remove all worktrees except for
                                      the main branch, with confirmation.
  pr [options] <prNumber>             Fetch the branch for a given GitHub PR
                                      number and create a worktree.
  config                              Manage CLI configuration settings.
  help [command]                      display help for command


Examples:

wt new feature/login
wt new feature/chat --checkout
wt new feature/auth -p ./auth-worktree
wt new feature/deps -i pnpm
wt new feature/vscode -e code

Assumptions:
* When running `wt new`, **append `-i pnpm`** to install packages with pnpm.
</file>

<file path=".cursor/rules/prompt-improve.mdc">
---
description:
globs:
alwaysApply: false
---
# Improve the User's Prompt Following the Patterns Below

> Practical prompt patterns to help anyone get clearer, more reliable answers from an AI agent.

| # | Pattern                       | Why It Matters                                                          | Template                                                                 | Example Prompt                                                                                             |
|---|-------------------------------|-------------------------------------------------------------------------|--------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------|
| 1 | Lead with the ask             | The model reads top-down; putting the goal first stops it wandering.    | `Do X. [context]`                                                        | "Summarize this PDF in 5 bullet points. The text is below: ..."                                            |
| 2 | Repeat the key ask at the end | Long contexts sometimes truncate; an end-cap protects you.              | `...[detail]... REMEMBER: Do X.`                                         | "List pros & cons, keep it balanced. REMEMBER: 5 pros, 5 cons."                                             |
| 3 | Specify output shape          | Dictating format cuts revision loops.                                   | `Return as: 1) short title, 2) table (CSV).`                             | "Give 3 holiday ideas. Format: destination, flight-time-hrs, avg cost."                                    |
| 4 | Use clear delimiters          | Backticks/headings/XML keep sections from blending.                     | `TEXT TO ANALYSE`                                                        | "Rate the style of the text between the fences."                                                            |
| 5 | Induce step-by-step thinking  | Planning first boosts multi-step accuracy.                              | `Think step-by-step then answer.`                                        | "Solve this puzzle. Think step-by-step before giving the final move."                                      |
| 6 | Ask it to plan its workflow   | For big jobs, AI outlines tasks before doing them.                      | `First draft a plan, wait, then execute.`                                | "We're writing an e-book. ❶ Outline chapters. ❷ Wait. ❸ When I say 'go', draft chapter 1."              |
| 7 | Limit or widen knowledge sources | Controls hallucination.                                               | `Use only the info below. / Combine basic knowledge + this context.`     | "Using only the product sheet below, write FAQs."                                                          |
| 8 | Guide information retrieval   | Helps AI pick the right docs before answering.                          | `List which docs look relevant, then answer.`                            | "30 sales memos attached. 1) Name the 5 most relevant. 2) Summarise their common points."                 |
| 9 | Show a style/example          | Anchors tone, length, vocabulary.                                       | `Match the style of: <example>`                                          | "Review this gadget in the style of the sample below: 'Short, witty, 3 key facts...'"                      |
| 10| Set correction handles        | One-line fixes let you steer quickly.                                   | `If length > 150 words, shorten.`                                        | "Describe blockchain to a child. If your answer is >150 words, cut it in half."                            |
| 11| Tell it when to stop or loop  | Prevents half-finished lists or runaway essays.                         | `Keep going until you list 20 ideas, then stop.`                         | "Brainstorm webinar titles. Give exactly 12, then finish."                                                  |
| 12| Request the hidden reasoning  | Good for audits; otherwise omit to keep it short.                       | `After the answer, include a brief reasoning section.`                   | "Which of these stocks looks over-valued? Answer first; add a 2-sentence rationale below a divider."        |
</file>

<file path=".cursor/rules/pull-request-create.mdc">
---
description:
globs:
alwaysApply: false
---
- Write a summary of everything from this conversation to `docs/pr/pr-body-file-<branch-name>.md` (use the actual branch name).
- Use the `gh` CLI to create a Pull Request, fill the title, etc., and use `--body-file ./docs/pr-body-file-<branch-name>.md`.

Example:
```bash
git push -u origin <branch-name>
gh pr create --title "feat: Enforce normalized, dash-separated, lowercase labels for all shells" --body-file docs/pr-body-file-fix-label-sanitization.md --fill
```
</file>

<file path=".cursor/rules/react-rules.mdc">
---
description:
globs:
alwaysApply: false
---
---
description:
globs:
alwaysApply: false
---
## React useEffect Dependency Rule

To avoid infinite loops with useEffect, don't put functions in the dependency array unless they're stable. For on-mount effects, use an empty array ([]). If a function must be a dependency, wrap it in useCallback

### Example
**Bad:**
```tsx
useEffect(() => {
  fetchNotes();
}, [fetchNotes]); // fetchNotes is re-created every render, causing an infinite loop
```

**Good:**
```tsx
useEffect(() => {
  fetchNotes();
}, []); // Only runs on mount
```

**If you need to use a function as a dependency:**
```tsx
const fetchNotes = useCallback(() => { ... }, []);
useEffect(() => {
  fetchNotes();
}, [fetchNotes]);
```
</file>

<file path=".cursor/rules/scripts-create.mdc">
---
description:
globs:
alwaysApply: false
---
# Creating Scripts

Create a `scripts` directory in the current project
Create TypeScript scripts that we'll run with the "bun" executable (but keep them fully compatible with node)
</file>

<file path=".cursor/rules/task-execute.mdc">
---
description:
globs:
alwaysApply: false
---
## Task Execution Guidance

Execute instructions provided in an included task file (e.g., `<task>.md`).*

- Follow the instructions in the included `<task>.md` file *exactly* as given.
- Before each commit, perform the specified **Verification** step(s) for that commit.
- After each successful `git commit`, update the corresponding commit title line in the `<task>.md` file with a ✅ emoji and the commit SHA hash.

## After Each Commit

- Agressively proceed working on the next commit without asking for input.
- Forge ahead until the entire task is completed

## A Task is Only Done Once These 3 Criteria are Met
1. The task is only done after all commits are complete
2. The task is only done after all tests pass
3. The task is only done after all verifications work

To be clear, the definition "Task Done" has 3 parts:
1. commits complete
2. tests pass
3. verifications work

## After the Task is Done

Once the task is done, run the `.cursor/rules/update-project.mdc` with the following information:
1. Failures that could have been avoided
2. Changes to project behavior or expectations
</file>

<file path=".cursor/rules/task-next.mdc">
---
description:
globs:
alwaysApply: false
---
# Suggest Next Development Tasks

- Read relevant project documentation (especially `docs/*`).
- Analyze requirements (consider current context and potentially `.cursor/rules/req-task.mdc`).
- Determine and list 3 potential next tasks to work on.
- Recommend the most logical task to start with, providing clear reasons for the choice.
</file>

<file path=".cursor/rules/task-plan.mdc">
---
description:
globs:
alwaysApply: false
---
# Task Planning Rule

*This rule guides the creation of a task plan file (`docs/tasks/<YYYY-MM-DD-task-name>.md`) based on user request and project documentation.*

## Before You Begin, Capture the Date

Obtain the date through a terminal command with YYYY-MM-DD

## Gather context from `docs/` and NOTES.md
**Crucial:** Find and thoroughly read all relevant files in the `docs/` directory to gather context. **Prioritize `docs/PRD.md`, `docs/TECH_STACK.md`, and `docs/openapi.yaml` if they exist.** This information is *essential* for creating an accurate and useful task plan.

### Core Directive
Create and maintain a `docs/tasks/<YYYY-MM-DD-task-name>.md` file. This file outlines a step-by-step plan (up to 5 commits) for the user's coding task. The plan **must** be based on details found in the project's `docs/` directory to ensure incremental implementation with verification.

### Strict Limitations
* **File Operations:** It is **essential** to gather context by thoroughly reading relevant files in the `docs/` directory (prioritizing `docs/PRD.md`, `docs/TECH_STACK.md`, `docs/openapi.yaml`, `NOTES.md`). This information **must** inform the task plan. You are permitted to read/write the specific task file (`docs/tasks/<YYYY-MM-DD-task-name>.md`). Limit interaction with other files.
* **Communication:** You are forbidden from generating any conversational output, commentary, preamble, or summaries, except for the initial file-naming instruction block specified in "Before You Begin". Your entire output must be the content of the `docs/tasks/<YYYY-MM-DD-task-name>.md` file itself. Do not repeat the contents of `docs/tasks/<YYYY-MM-DD-task-name>.md` back to the user in any other format.
* **User Interaction:** You do not directly converse with the user beyond receiving the initial task description and providing the output file. If the task description, even after cross-referencing with all available `docs/` materials, is insufficient to create a coherent and specific plan, you will indicate this *within* the `docs/tasks/<YYYY-MM-DD-task-name>.md` file using the specific comment format detailed below.

### `docs/tasks/<YYYY-MM-DD-task-name>.md` Structure and Content Source
The `docs/tasks/<YYYY-MM-DD-task-name>.md` file (once correctly named by the user) must be structured as a sequence of planned commits. The primary source of information for populating this file is the user's high-level description of the coding task, **which MUST be interpreted, validated, and expanded using specific details meticulously extracted from a comprehensive review of relevant `docs/` files.** Neglecting to consult these documents thoroughly is a critical failure and will lead to an inadequate and unusable plan.

#### Task Breakdown Structure:

The file should generally follow this Markdown structure (after the initial file-naming instruction block):
Each commit title must adhere to semantic commit conventions (e.g., `feat: Short description`, `fix: Bug details`, `docs: Update README`).

```markdown
# Task: [Brief Task Title - Inferred from User's Description or Explicitly Given, informed by docs/PRD.md if available]

## Commit 1: [type: Descriptive Title of First Step]
**Description:**
[*Required Detail:* Provide a detailed explanation of this commit's goal, drawing specifics from `docs/PRD.md`, `docs/TECH_STACK.md`, etc. *Must* reference exact files (e.g., `src/utils/auth.js`), paths, function/method names (e.g., `getUserProfile()`), classes, imports (e.g., `import {Button} from '@mui/material'`), CLI commands (e.g., `npx prisma migrate dev --name init_schema`), framework APIs (e.g., `app.use(cors())`), or other precise technical details. Vague descriptions are insufficient.]

**Verification:**
[*Required Detail:* Provide explicit, actionable steps to confirm correctness *before* committing. Include specific commands (e.g., `npm run test:unit -- src/services/userService.test.js`, `curl ...`), scripts, paths, UI elements by ID/class (e.g., "Verify `<div id=\"user-greeting\">` displays username per `docs/PRD.md`"), or precise expected outputs. Vague steps like "Test the feature" are insufficient.]

---

## Commit 2: [type: Descriptive Title of Second Step]
**Description:**
[As above, CRITICALLY detailed and specific, referencing exact files, paths, functions, commands, libraries, frameworks, etc., all derived from or consistent with information in the `docs/` directory.]

**Verification:**
[As above, CRITICALLY detailed and specific, referencing exact commands, scripts, outputs, UI elements, etc., and aligned with any testing or QA guidelines in `docs/`.]

---
... (Up to 5 commits)

---
```

#### Handling Insufficient Information and Ambiguity:
If, after a **thorough review** of all relevant `docs/` files, the required specificity for file paths, function names, commands, etc., is still missing for a **Description** or **Verification** step, **do not invent details**. Insert an HTML comment (`<!-- TODO: ... -->`) at the point of ambiguity, clearly stating the specific information needed and potentially referencing the relevant `docs/` file where it might be found. Use information from `docs/TECH_STACK.md` to guide the type of detail requested (e.g., component names for React, model names for Django).
</file>

<file path=".cursor/rules/zen-coding.mdc">
---
description:
globs:
alwaysApply: false
---
# Follow the Zen of Coding
- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Flat is better than nested.
- Sparse is better than dense.
- Readability counts.
- Special cases aren't special enough to break the rules.
- Although practicality beats purity.
- Errors should never pass silently.
- Unless explicitly silenced.
- In the face of ambiguity, refuse the temptation to guess.
- There should be one-- and preferably only one --obvious way to do it.
- Although that way may not be obvious at first unless you're Dutch.
- Now is better than never.
- Although never is often better than *right* now.
- If the implementation is hard to explain, it's a bad idea.
- If the implementation is easy to explain, it may be a good idea.
</file>

<file path="docs/tasks/2025-05-09-send-flag-interactive-input.md">
# Task: Add --send flag for interactive input to child process

## Commit 1: test: Add integration test for --send flag ✅ d12c72e92aac09a22784cf674f1b42422bd7d961
**Description:**
Create a new integration test in `test/integration/` that launches a process requiring user input (e.g., a script that prompts for yes/no), runs the CLI tool to wrap it, and verifies that sending input via the new `--send` flag allows the process to proceed. Reference the CLI entry point (likely `src/index.ts`).

**Verification:**
Run `pnpm test` and confirm the new test in `test/integration/` passes, verifying that the process receives the sent input and completes as expected.

---

## Commit 2: feat: Add --send flag to CLI ✅ eb51aa0b0adaf90ee5aadeb3311ab4c6decdd0da
**Description:**
Update the CLI implementation (likely in `src/index.ts`) to accept a `--send <input>` flag. Implement logic to forward the provided input string to the stdin of the running child process. Ensure this works for both new and existing processes.

**Verification:**
Run the CLI with a process that waits for input, use the `--send` flag, and confirm the input is received by the child process. Check logs for confirmation.

---

## Commit 3: feat: Log all --send input events ✅ c16272f47d7589288cd25deedae61ea8f9480d0b
**Description:**
Add logging (in `src/index.ts` or relevant logger module) for every time input is sent to the child process via `--send`. Log the input, timestamp, and process PID for observability.

**Verification:**
Run the CLI with `--send`, check the log output for the correct log entry with input, timestamp, and PID.

---

## Commit 4: fix: Robust error handling for --send flag ✅ 6b797d2beec70ab9d36376ab030e7f2345f5ed8f
**Description:**
Add error handling for cases where the process is not running, stdin is closed, or input cannot be sent. Ensure user-friendly error messages and log all failures.

**Verification:**
Attempt to use `--send` when no process is running or after process exit. Confirm error messages are shown and errors are logged.

---

## Commit 5: docs: Document --send flag in README ✅ dda403201cee3d5cde1e2bbde34003fa9b306b19
**Description:**
Update `README.md` to describe the new `--send` flag, usage examples, and caveats. Reference the integration test and log output for clarity.

**Verification:**
Check `README.md` for a new section on `--send`, including example commands and expected behavior.

---

<!-- TODO: No docs/ or NOTES.md found. If project documentation is added, update this plan with file/function/command specifics. -->
</file>

<file path="test/integration/spawn-wrapper-ipc-request-logs.test.d.ts">
export {};
</file>

<file path="test/integration/spawn-wrapper-nextjs-dev.test.d.ts">
export {};
</file>

<file path="test/integration/spawn-wrapper-passthrough.test.ts">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { spawn } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';
import fsSync from 'node:fs';

const LOG_DIR = path.resolve(__dirname, '../../tmp/passthrough_test_logs');
const LOG_PREFIX = 'passthrough_test_';

function wait(ms: number) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

async function waitForSocket(socketPath: string, timeoutMs = 10000) {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
        if (fsSync.existsSync(socketPath)) return;
        await wait(100);
    }
    throw new Error(`Timeout waiting for IPC socket: ${socketPath}`);
}

describe('chopup minimal passthrough integration', () => {
    let child: ReturnType<typeof spawn> | null = null;
    let logFilesBefore: string[] = [];
    let chopupPid: number | null = null;
    let socketPath = '';

    beforeAll(async () => {
        await fs.mkdir(LOG_DIR, { recursive: true });
        logFilesBefore = await fs.readdir(LOG_DIR);
    });

    afterAll(async () => {
        if (child && !child.killed) child.kill('SIGKILL');
        // Clean up: remove new log files
        const logFilesAfter = await fs.readdir(LOG_DIR);
        const newFiles = logFilesAfter.filter(f => !logFilesBefore.includes(f));
        for (const file of newFiles) {
            await fs.unlink(path.join(LOG_DIR, file));
        }
    });

    it('should chop logs on IPC request (echo passthrough)', async () => {
        let timeoutHandle: NodeJS.Timeout | null = null;
        let finished = false;
        const failOnTimeout = (done: () => void) => {
            if (finished) return;
            console.error('[TEST_TIMEOUT] Test exceeded 30s. Forcing cleanup and fail.');
            if (child && !child.killed) child.kill('SIGKILL');
            finished = true;
            done();
            throw new Error('Test timed out after 30s');
        };
        await new Promise<void>((resolve, reject) => {
            timeoutHandle = setTimeout(() => failOnTimeout(reject), 30000);
            (async () => {
                try {
                    // Start chopup wrapping a process that produces output for a few seconds
                    child = spawn('pnpm', [
                        'exec', 'tsx', 'src/index.ts',
                        '--log-dir', LOG_DIR,
                        '--log-prefix', LOG_PREFIX,
                        '--',
                        'sh', '-c', 'yes | head -n 10 && sleep 2',
                    ], {
                        cwd: path.resolve(__dirname, '../../'),
                        stdio: ['ignore', 'pipe', 'inherit'],
                    });

                    // Parse PID and socket from chopup stdout, and wait for at least one log line
                    let stdoutData = '';
                    let foundPid = false;
                    let foundSocket = false;
                    let sawLogLine = false;
                    await new Promise<void>((resolve2, reject2) => {
                        const timeout = setTimeout(() => {
                            reject2(new Error(`Timeout waiting for PID, socket, and log output. Output so far: ${stdoutData}`));
                        }, 10000);
                        if (!child || !child.stdout) {
                            reject2(new Error('Child process or stdout is not available.'));
                            return;
                        }
                        child.stdout.on('data', (data) => {
                            stdoutData += data.toString();
                            if (!foundPid) {
                                const match = stdoutData.match(/\[CHOPUP\] PID: (\d+)/);
                                if (match) {
                                    chopupPid = Number.parseInt(match[1], 10);
                                    foundPid = true;
                                }
                            }
                            if (foundPid && !foundSocket) {
                                const sockMatch = stdoutData.match(/\[CHOPUP\] IPC socket: (.+)/);
                                if (sockMatch) {
                                    socketPath = sockMatch[1];
                                    foundSocket = true;
                                }
                            }
                            if (stdoutData.match(/\[CHILD_STDOUT\]/)) {
                                sawLogLine = true;
                            }
                            if (foundPid && foundSocket && sawLogLine) {
                                clearTimeout(timeout);
                                resolve2();
                            }
                        });
                    });
                    if (!foundSocket) {
                        // Wait up to 2 more seconds for the socket line
                        const start = Date.now();
                        while (!foundSocket && Date.now() - start < 2000) {
                            await wait(100);
                            const sockMatch = stdoutData.match(/\[CHOPUP\] IPC socket: (.+)/);
                            if (sockMatch) {
                                socketPath = sockMatch[1];
                                foundSocket = true;
                            }
                        }
                    }
                    if (!foundSocket) {
                        throw new Error(`Did not find IPC socket line in output. Output so far: ${stdoutData}`);
                    }
                    expect(chopupPid).toBeGreaterThan(0);
                    expect(socketPath).toMatch(/chopup_\d+\.sock/);
                    expect(sawLogLine).toBe(true);

                    // Wait for socket to exist
                    await waitForSocket(socketPath);

                    // Log chop request
                    const logPath = await new Promise<string>((resolve3, reject3) => {
                        const req = spawn('pnpm', [
                            'exec', 'tsx', 'src/index.ts',
                            '--pid', String(chopupPid),
                        ], {
                            cwd: path.resolve(__dirname, '../../'),
                            stdio: ['ignore', 'pipe', 'inherit'],
                        });
                        let output = '';
                        req.stdout.on('data', (data) => {
                            output += data.toString();
                        });
                        req.on('close', () => {
                            const match = output.match(/New log file created: (.*)/);
                            if (match) resolve3(match[1].trim());
                            else reject3(new Error(`No log file path in output: ${output}`));
                        });
                    });
                    const logExists = await fs.access(logPath).then(() => true, () => false);
                    expect(logExists).toBe(true);
                    const logLines = (await fs.readFile(logPath, 'utf8')).split('\n').filter(Boolean).length;
                    expect(logLines).toBeGreaterThan(0);
                    finished = true;
                    if (timeoutHandle) clearTimeout(timeoutHandle);
                    resolve();
                } catch (err) {
                    finished = true;
                    if (timeoutHandle) clearTimeout(timeoutHandle);
                    reject(err);
                }
            })();
        });
    }, 15000);
});
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

tmp

# GitHub Actions workflows (do NOT ignore these)
!.github/
!.github/workflows/
</file>

<file path=".cursor/rules/_project.mdc">
---
description: 
globs: 
alwaysApply: true
---
# chopup - Project Rules

## 1. Project Overview

goal: CLI tool to wrap long-running processes, segment their logs, and send input to them, all managed via IPC. Also monitors files for changes to trigger log chopping (future feature).
type: CLI Tool
key features:
- Wraps and runs any user-specified command using the `run` subcommand (default).
- Captures stdout and stderr from the wrapped process.
- Segments/chops logs into new files in a specified log directory on IPC request (`request-logs` command).
- Allows sending input strings to the stdin of the wrapped process via IPC (`send-input` command and `--send` flag).
- Graceful shutdown using `tree-kill` for robust process tree cleanup.
- IPC server (Node.js `net` module via Unix domain sockets) for on-demand log chopping and input sending.
- (Planned) Monitors a specified file or directory for changes to trigger log chopping.

## 2. Technology Stack

language(s): TypeScript ^5.8.3 (strict mode, target: es2016, module: commonjs)
framework(s): None (CLI, not web)
ui library/styling: N/A
database(s): N/A
state management: N/A
api layer: N/A (IPC via Node.js `net` module)
key libraries:
- commander (CLI parsing)
- chokidar (File watching - planned)
- tree-kill (Process tree cleanup)
- vitest (Testing)
- tsx (Development execution of TypeScript)
- @biomejs/biome (Formatting and linting)

## 3. Project Structure

main source directory: src/
core directories:
- src/: Main TypeScript source (index.ts)
- dist/: Compiled JavaScript output
- test/integration/: Integration tests (Vitest)
- test/integration/input-tests/: Input scenario integration tests
- test/integration/input-tests/fixtures/scripts/: Dummy CLI scripts for input tests
- test/integration/test-utils/: Test helpers (e.g., input-helpers.ts)
- tmp/: Temporary files generated during tests (e.g., test scripts, logs)
- docs/tasks/: Task breakdown files
diagram/link: N/A

## 4. Coding Standards & Conventions

language usage: Strict TypeScript (strict mode enabled), async/await, use `node:` prefixed imports for built-in modules. Avoid `any`. Use optional chaining (`?.`) for cleaner property access.
naming conventions:
- files/folders: kebab-case (e.g., `src/my-module.ts`, `docs/tasks/`)
- variables/functions: camelCase
- types/interfaces: PascalCase (e.g., `LogBufferEntry`, `ChopupInstance`)
code style/formatting: @biomejs/biome (configured via CLI or package.json scripts). Use `pnpm format`.
comments: English. JSDoc for public APIs and complex types/functions. Use `TODO:` for pending work.
imports: Grouped (Node.js built-in, external/npm packages, internal project modules).

## 5. Key Principles & Best Practices

- Observability: Log all key events (IPC requests/responses, process start/exit, errors, input sending, log chopping).
- Robustness: Handle errors gracefully (e.g., IPC connection issues, file system errors), validate paths and inputs, ensure bulletproof process cleanup.
- User Experience: Clear CLI subcommands (`run`, `request-logs`, `send-input`) and options, helpful error messages, predictable behavior.
- Modularity: CLI subcommands provide separation of concerns. Core logic in `mainAction`.
- Bulletproof process cleanup: Mandate `tree-kill` for all child/grandchild processes spawned by the wrapped command, both in the CLI tool and in tests for teardown.

## 6. Testing

framework: Vitest
types: Integration tests for CLI subcommands (`run`, `request-logs`, `send-input`), IPC communication, log chopping, input sending, and process lifecycle management. Input scenario tests cover single-char, multi-char, empty, and edge-case inputs.
location: `test/integration/` (main), `test/integration/input-tests/` (input scenarios), `test/integration/test-utils/` (helpers)

## 7. Tooling & Workflow

package manager: pnpm (see `packageManager` in package.json)
build command(s): `pnpm build` (runs `tsc`)
run command(s):
  - Main application: `pnpm dev -- run -- <command_to_wrap...>`, `pnpm start -- run -- <command_to_wrap...>`, `node dist/index.js run -- <command_to_wrap...>`, `chopup run -- <command_to_wrap...>`
  - Requesting logs: `pnpm dev -- request-logs --socket <socket-path>`, `chopup request-logs --socket <socket-path>`
  - Sending input: `pnpm dev -- send-input --socket <socket-path> --input "<string>"`, `chopup send-input --socket <socket-path> --input "<string>"`, `--send` flag
version control: Git. Conventional Commits required (e.g., `feat:`, `fix:`, `chore:`). Never push failing tests.
ci/cd: N/A (as of now)

## 8. (Optional) Database / API Guidelines

N/A (No database or traditional web API)

## 9. (Optional) Specific Feature Rules

- Log Chopping: Logs are chopped on `request-logs` IPC command. Each chop includes logs since the last chop time. A final chop occurs on graceful process exit.
- Input Sending: Input is sent to the wrapped process's stdin via the `send-input` IPC command or `--send` flag. The command takes the target IPC socket and the input string. Tests cover single-char, multi-char, empty, and edge-case inputs.
- IPC: Communication between `chopup` instances (main `run` and client commands like `request-logs`, `send-input`) happens over a Unix domain socket. The `run` command prints its socket path on startup.
- CLI Structure: The tool uses subcommands (`run`, `request-logs`, `send-input`). `run` is the default command.
- Process Cleanup: `tree-kill` is critical. It's used in the main `run` command's shutdown logic and in test teardowns to ensure no orphaned processes.
- Integration Test Observability: All dummy scripts and helpers log key events. Tests verify process cleanup, log file creation, and correct input handling.

## 10. (Optional) Rule Referencing

- See [always-global.mdc](mdc:.cursor/rules/always-global.mdc) for overarching global development principles.

---

# Project Update Notes

## 1. Avoidable Failures
- Initial test app contained invalid TypeScript/JSX, breaking the build. Solution: Use valid Next.js page export.
- TypeScript build failed due to test/ and tmp/ files outside rootDir. Solution: Added "exclude": ["test", "tmp"] to tsconfig.json.
- TypeScript build failed due to dist/index.d.ts overwrite. Solution: Manually removed dist/index.d.ts and rebuilt.

## 2. Changes to Project Behavior/Expectations
- CLI now supports direct passthrough: `npx chopup pnpm dev` (with required options), no subcommand required.
- Tests updated to verify passthrough CLI behavior.
- tsconfig.json now excludes test/ and tmp/ from build.
</file>

<file path="test/integration/input-tests/fixtures/scripts/echo-input.js">
#!/usr/bin/env node

const fs = require("node:fs");
const path = require("node:path");

const outputFilePath = process.argv[2];

if (!outputFilePath) {
	console.error("Error: Output file path argument missing.");
	process.exit(1);
}

console.log("[ECHO_INPUT] Script started. Output file:", outputFilePath);
// Ensure the directory for the output file exists
const outputDir = path.dirname(outputFilePath);
if (!fs.existsSync(outputDir)) {
	fs.mkdirSync(outputDir, { recursive: true });
}

const writeStream = fs.createWriteStream(outputFilePath);

process.stdin.on("data", (data) => {
	console.log("[ECHO_INPUT] Received input:", data.toString());
	writeStream.write(data);
});

process.stdin.on("end", () => {
	writeStream.end(() => {
		console.log("[ECHO_INPUT] Exiting. Wrote input to file.");
	});
});

writeStream.on("error", (err) => {
	console.error("Error writing to output file:", err);
	process.exit(1);
});

// Keep the process alive until stdin is closed or an explicit exit
// For this simple echo, it will exit when stdin is closed by the parent.
</file>

<file path="test/integration/input-tests/fixtures/scripts/text-entry-prompt.js">
#!/usr/bin/env node

const fs = require("node:fs");
const path = require("node:path");
const readline = require("node:readline");

const outputFile = process.argv[2];

if (!outputFile) {
	console.error("Error: Output file path argument missing.");
	process.exit(1);
}

console.log("[TEXT_ENTRY_PROMPT] Script started. Output file:", outputFile);
const outputDir = path.dirname(outputFile);
if (!fs.existsSync(outputDir)) {
	fs.mkdirSync(outputDir, { recursive: true });
}

const writeStream = fs.createWriteStream(outputFile);
const rl = readline.createInterface({
	input: process.stdin,
	output: process.stdout,
});

let handled = false;
const finish = (answer) => {
	if (handled) return;
	handled = true;
	console.log("[TEXT_ENTRY_PROMPT] Received input:", answer);
	fs.writeFile(outputFile, `Name entered: ${answer}\n`, (err) => {
		if (err) {
			console.error(`Error writing to output file: ${err.message}`);
			process.exit(1);
		} else {
			console.log(
				"[TEXT_ENTRY_PROMPT] Exiting. Wrote response:",
				`Name entered: ${answer}`,
			);
			process.exit(0);
		}
	});
};

rl.on("line", (line) => {
	finish(line);
});

setTimeout(() => {
	if (!handled) finish("");
}, 1000);
</file>

<file path="test/integration/input-tests/text-entry.test.ts">
import path from 'node:path';
import fs from 'node:fs/promises';
import { describe, expect, it, beforeAll, afterAll } from 'vitest';
import {
    spawnChopupWithScript,
    type ChopupInstance,
    TMP_DIR
} from '../test-utils/input-helpers';
import fsSync from 'node:fs';

const SCRIPT_NAME = 'text-entry-prompt.js';
const FIXTURES_DIR = path.resolve(__dirname, 'fixtures/scripts');
const scriptPath = path.join(FIXTURES_DIR, SCRIPT_NAME);

describe('Text Entry Input Test', () => {
    let chopupInstance: ChopupInstance | null = null;

    beforeAll(async () => {
        console.log('[TEXT_ENTRY_TEST] beforeAll: chmod script');
        try {
            await fs.access(scriptPath, fs.constants.X_OK);
        } catch {
            await fs.chmod(scriptPath, '755');
        }
    });

    afterAll(async () => {
        console.log('[TEXT_ENTRY_TEST] afterAll: cleaning up chopupInstance');
        if (chopupInstance) {
            await chopupInstance.cleanup();
            chopupInstance = null;
        }
        console.log('[TEXT_ENTRY_TEST] Waiting 500ms after cleanup for OS to release socket');
        await new Promise(r => setTimeout(r, 500));
        console.log('[TEXT_ENTRY_TEST] Done waiting after cleanup');
    });

    it('should send "John Doe" and verify "Name entered: John Doe" output', async () => {
        console.log('[TEXT_ENTRY_TEST] Test start: John Doe');
        const testId = 'john_doe';
        const testRunId = `text-entry-tests_${Date.now()}`;
        const baseLogDir = path.join(TMP_DIR, 'input-test-logs', testRunId);
        const outputDir = path.join(baseLogDir, 'outputs');
        await fs.mkdir(outputDir, { recursive: true });
        const outputFile = path.join(outputDir, `${testId}_output.txt`);
        let logPrefix = `${testId}_${Date.now()}`;
        console.log('[TEXT_ENTRY_TEST] Paths:', { testId, testRunId, baseLogDir, outputDir, outputFile, logPrefix });
        if (chopupInstance) await chopupInstance.cleanup();
        chopupInstance = null;
        chopupInstance = await spawnChopupWithScript(scriptPath, [outputFile], logPrefix, 5000);
        const inputText = 'John Doe';
        await chopupInstance.sendInput(`${inputText}\n`);
        let output = '';
        let found = false;
        const start = Date.now();
        while (Date.now() - start < 1000) {
            output = await chopupInstance.getWrappedProcessOutput();
            if (output.trim() === 'Name entered: John Doe') {
                found = true;
                break;
            }
            await new Promise(r => setTimeout(r, 100));
        }
        console.log('[TEXT_ENTRY_TEST] Output:', output.trim());
        expect(found).toBe(true);
        await chopupInstance.cleanup();
        chopupInstance = null;
        console.log('[TEXT_ENTRY_TEST] Test end: John Doe, cleaned up all state');
    }, 5000);

    it('should handle an empty string input (just Enter) and verify "Name entered:" output', async () => {
        console.log('[TEXT_ENTRY_TEST] Test start: empty string');
        const testId = 'empty_string';
        const testRunId = `text-entry-tests_${Date.now()}`;
        const baseLogDir = path.join(TMP_DIR, 'input-test-logs', testRunId);
        const outputDir = path.join(baseLogDir, 'outputs');
        await fs.mkdir(outputDir, { recursive: true });
        const outputFile = path.join(outputDir, `${testId}_output.txt`);
        if (chopupInstance) await chopupInstance.cleanup();
        chopupInstance = null;
        console.log('[TEXT_ENTRY_TEST] Spawning chopupInstance');
        const logPrefix = `${testId}_${Date.now()}`;
        chopupInstance = await spawnChopupWithScript(scriptPath, [outputFile], logPrefix, 5000);
        console.log('[TEXT_ENTRY_TEST] Sending input: <empty>');
        await chopupInstance.sendInput('\n');
        let output = '';
        let found = false;
        const expected = 'Name entered:';
        const start = Date.now();
        while (Date.now() - start < 1000) {
            output = await chopupInstance.getWrappedProcessOutput();
            if (output.trim() === expected) {
                found = true;
                break;
            }
            await new Promise(r => setTimeout(r, 100));
        }
        console.log('[TEXT_ENTRY_TEST] Output:', output.trim());
        expect(found).toBe(true);
        console.log('[TEXT_ENTRY_TEST] Cleaning up chopupInstance');
        await chopupInstance.cleanup();
        chopupInstance = null;
        console.log('[TEXT_ENTRY_TEST] Test end: empty string');
    }, 5000);

    it('should handle input with leading/trailing spaces and verify correct output', async () => {
        console.log('[TEXT_ENTRY_TEST] Test start: leading/trailing spaces');
        const testId = 'leading_trailing_spaces';
        const testRunId = `text-entry-tests_${Date.now()}`;
        const baseLogDir = path.join(TMP_DIR, 'input-test-logs', testRunId);
        const outputDir = path.join(baseLogDir, 'outputs');
        await fs.mkdir(outputDir, { recursive: true });
        const outputFile = path.join(outputDir, `${testId}_output.txt`);
        if (chopupInstance) await chopupInstance.cleanup();
        chopupInstance = null;
        console.log('[TEXT_ENTRY_TEST] Spawning chopupInstance');
        const logPrefix = `${testId}_${Date.now()}`;
        chopupInstance = await spawnChopupWithScript(scriptPath, [outputFile], logPrefix, 5000);
        const inputText = '   leading and trailing spaces  ';
        console.log('[TEXT_ENTRY_TEST] Sending input:', inputText);
        await chopupInstance.sendInput(`${inputText}\n`);
        let output = '';
        let found = false;
        const start = Date.now();
        while (Date.now() - start < 1000) {
            output = await chopupInstance.getWrappedProcessOutput();
            if (output.trim() === 'Name entered:   leading and trailing spaces  ') {
                found = true;
                break;
            }
            await new Promise(r => setTimeout(r, 100));
        }
        console.log('[TEXT_ENTRY_TEST] Output:', output.trim());
        expect(found).toBe(true);
        console.log('[TEXT_ENTRY_TEST] Cleaning up chopupInstance');
        await chopupInstance.cleanup();
        chopupInstance = null;
        console.log('[TEXT_ENTRY_TEST] Test end: leading/trailing spaces');
    }, 5000);
});
</file>

<file path="test/integration/spawn-wrapper-nextjs-dev.test.ts">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { spawn } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';
import fsSync from 'node:fs';

const TEST_APP_DIR = path.resolve(__dirname, '../../tmp/nextjs-test-app');
const LOG_DIR = path.resolve(__dirname, '../../tmp/advanced_test_logs');
const LOG_PREFIX = 'next_dev_test_';

function wait(ms: number) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

async function waitForSocket(socketPath: string, timeoutMs = 20000) {
    const start = Date.now();
    while (Date.now() - start < timeoutMs) {
        if (fsSync.existsSync(socketPath)) return;
        await wait(200);
    }
    throw new Error(`Timeout waiting for IPC socket: ${socketPath}`);
}

/**
 * EXTENDED/REAL-WORLD TEST: This test wraps a real Next.js dev server.
 * It is slow and may be flaky due to Next.js startup and output buffering.
 * Use for real-world coverage, not as a required smoke test.
 *
 * SKIPPED BY DEFAULT for reliability. Remove .skip to run manually.
 */
describe.skip('chopup EXTENDED integration: next dev server (IPC log chop)', () => {
    let child: ReturnType<typeof spawn> | null = null;
    let logFilesBefore: string[] = [];
    let chopupPid: number | null = null;

    beforeAll(async () => {
        // Ensure log dir exists and is clean
        await fs.mkdir(LOG_DIR, { recursive: true });
        logFilesBefore = await fs.readdir(LOG_DIR);
    });

    afterAll(async () => {
        if (child && !child.killed) child.kill('SIGKILL');
        // Clean up: remove new log files
        const logFilesAfter = await fs.readdir(LOG_DIR);
        const newFiles = logFilesAfter.filter(f => !logFilesBefore.includes(f));
        for (const file of newFiles) {
            await fs.unlink(path.join(LOG_DIR, file));
        }
    });

    it('should chop logs on IPC request (tsx dev)', async () => {
        let timeoutHandle: NodeJS.Timeout | null = null;
        let finished = false;
        const failOnTimeout = (done: () => void) => {
            if (finished) return;
            console.error('[TEST_TIMEOUT] Test exceeded 30s. Forcing cleanup and fail.');
            if (child && !child.killed) child.kill('SIGKILL');
            finished = true;
            done();
            throw new Error('Test timed out after 30s');
        };
        await new Promise<void>((resolve, reject) => {
            timeoutHandle = setTimeout(() => failOnTimeout(reject), 30000);
            (async () => {
                try {
                    // Start chopup wrapping next dev
                    child = spawn('pnpm', [
                        'exec', 'tsx', 'src/index.ts',
                        '--log-dir', LOG_DIR,
                        '--log-prefix', LOG_PREFIX,
                        '--',
                        'next', 'dev',
                    ], {
                        cwd: path.resolve(__dirname, '../../'),
                        stdio: ['ignore', 'pipe', 'inherit'],
                    });

                    // Parse PID and socket from chopup stdout (robust)
                    let stdoutData = '';
                    let foundPid = false;
                    let foundSocket = false;
                    let socketPath = '';
                    await new Promise<void>((resolve2, reject2) => {
                        const timeout = setTimeout(() => {
                            reject2(new Error(`Timeout waiting for PID and socket output. Output so far: ${stdoutData}`));
                        }, 20000);
                        if (!child || !child.stdout) {
                            reject2(new Error('Child process or stdout is not available.'));
                            return;
                        }
                        child.stdout.on('data', (data) => {
                            stdoutData += data.toString();
                            if (!foundPid) {
                                const match = stdoutData.match(/\[CHOPUP\] PID: (\d+)/);
                                if (match) {
                                    chopupPid = Number.parseInt(match[1], 10);
                                    foundPid = true;
                                }
                            }
                            if (foundPid && !foundSocket) {
                                const sockMatch = stdoutData.match(/\[CHOPUP\] IPC socket: (.+)/);
                                if (sockMatch) {
                                    socketPath = sockMatch[1];
                                    foundSocket = true;
                                    clearTimeout(timeout);
                                    resolve2();
                                }
                            }
                        });
                    });
                    if (!foundSocket) {
                        // Wait up to 5 more seconds for the socket line
                        const start = Date.now();
                        while (!foundSocket && Date.now() - start < 5000) {
                            await wait(100);
                            const sockMatch = stdoutData.match(/\[CHOPUP\] IPC socket: (.+)/);
                            if (sockMatch) {
                                socketPath = sockMatch[1];
                                foundSocket = true;
                            }
                        }
                    }
                    if (!foundSocket) {
                        // Print all output for debugging
                        throw new Error(`Did not find IPC socket line in output. Output so far: ${stdoutData}`);
                    }
                    expect(chopupPid).toBeGreaterThan(0);
                    expect(socketPath).toMatch(/chopup_\d+\.sock/);

                    // Wait for dev server to start
                    await wait(10000); // 10s for Next.js to boot

                    // Wait for socket to exist
                    await waitForSocket(socketPath);

                    // First log chop request
                    const firstLogPath = await new Promise<string>((resolve3, reject3) => {
                        const req = spawn('pnpm', [
                            'exec', 'tsx', 'src/index.ts',
                            '--pid', String(chopupPid),
                        ], {
                            cwd: path.resolve(__dirname, '../../'),
                            stdio: ['ignore', 'pipe', 'inherit'],
                        });
                        let output = '';
                        req.stdout.on('data', (data) => {
                            output += data.toString();
                        });
                        req.on('close', () => {
                            const match = output.match(/New log file created: (.*)/);
                            if (match) resolve3(match[1].trim());
                            else reject3(new Error(`No log file path in output: ${output}`));
                        });
                    });
                    const firstLogExists = await fs.access(firstLogPath).then(() => true, () => false);
                    expect(firstLogExists).toBe(true);
                    const firstLogLines = (await fs.readFile(firstLogPath, 'utf8')).split('\n').filter(Boolean).length;
                    expect(firstLogLines).toBeGreaterThan(0);
                    finished = true;
                    if (timeoutHandle) clearTimeout(timeoutHandle);
                    resolve();
                } catch (err) {
                    finished = true;
                    if (timeoutHandle) clearTimeout(timeoutHandle);
                    reject(err);
                }
            })();
        });
    }, 60000);

    it('should chop logs on IPC request (built CLI passthrough)', async () => {
        let timeoutHandle: NodeJS.Timeout | null = null;
        let finished = false;
        const failOnTimeout = (done: () => void) => {
            if (finished) return;
            console.error('[TEST_TIMEOUT] Test exceeded 30s. Forcing cleanup and fail.');
            if (child && !child.killed) child.kill('SIGKILL');
            finished = true;
            done();
            throw new Error('Test timed out after 30s');
        };
        await new Promise<void>((resolve, reject) => {
            timeoutHandle = setTimeout(() => failOnTimeout(reject), 30000);
            (async () => {
                try {
                    // Start chopup as built CLI, passthrough mode
                    child = spawn('node', [
                        'dist/index.js',
                        '--log-dir', LOG_DIR,
                        '--log-prefix', LOG_PREFIX,
                        'pnpm', 'dev',
                    ], {
                        cwd: path.resolve(__dirname, '../../'),
                        stdio: ['ignore', 'pipe', 'inherit'],
                    });

                    // Parse PID and socket from chopup stdout (robust)
                    let stdoutData = '';
                    let foundPid = false;
                    let foundSocket = false;
                    let socketPath = '';
                    await new Promise<void>((resolve2, reject2) => {
                        const timeout = setTimeout(() => {
                            reject2(new Error(`Timeout waiting for PID and socket output. Output so far: ${stdoutData}`));
                        }, 20000);
                        if (!child || !child.stdout) {
                            reject2(new Error('Child process or stdout is not available.'));
                            return;
                        }
                        child.stdout.on('data', (data) => {
                            stdoutData += data.toString();
                            if (!foundPid) {
                                const match = stdoutData.match(/\[CHOPUP\] PID: (\d+)/);
                                if (match) {
                                    chopupPid = Number.parseInt(match[1], 10);
                                    foundPid = true;
                                }
                            }
                            if (foundPid && !foundSocket) {
                                const sockMatch = stdoutData.match(/\[CHOPUP\] IPC socket: (.+)/);
                                if (sockMatch) {
                                    socketPath = sockMatch[1];
                                    foundSocket = true;
                                    clearTimeout(timeout);
                                    resolve2();
                                }
                            }
                        });
                    });
                    if (!foundSocket) {
                        // Wait up to 5 more seconds for the socket line
                        const start = Date.now();
                        while (!foundSocket && Date.now() - start < 5000) {
                            await wait(100);
                            const sockMatch = stdoutData.match(/\[CHOPUP\] IPC socket: (.+)/);
                            if (sockMatch) {
                                socketPath = sockMatch[1];
                                foundSocket = true;
                            }
                        }
                    }
                    if (!foundSocket) {
                        // Print all output for debugging
                        throw new Error(`Did not find IPC socket line in output. Output so far: ${stdoutData}`);
                    }
                    expect(chopupPid).toBeGreaterThan(0);
                    expect(socketPath).toMatch(/chopup_\d+\.sock/);

                    // Wait for dev server to start
                    await wait(10000); // 10s for Next.js to boot

                    // Wait for socket to exist
                    await waitForSocket(socketPath);

                    // Log chop request
                    const logPath = await new Promise<string>((resolve3, reject3) => {
                        const req = spawn('node', [
                            'dist/index.js',
                            '--pid', String(chopupPid),
                        ], {
                            cwd: path.resolve(__dirname, '../../'),
                            stdio: ['ignore', 'pipe', 'inherit'],
                        });
                        let output = '';
                        req.stdout.on('data', (data) => {
                            output += data.toString();
                        });
                        req.on('close', () => {
                            const match = output.match(/New log file created: (.*)/);
                            if (match) resolve3(match[1].trim());
                            else reject3(new Error(`No log file path in output: ${output}`));
                        });
                    });
                    const logExists = await fs.access(logPath).then(() => true, () => false);
                    expect(logExists).toBe(true);
                    const logLines = (await fs.readFile(logPath, 'utf8')).split('\n').filter(Boolean).length;
                    expect(logLines).toBeGreaterThan(0);
                    finished = true;
                    if (timeoutHandle) clearTimeout(timeoutHandle);
                    resolve();
                } catch (err) {
                    finished = true;
                    if (timeoutHandle) clearTimeout(timeoutHandle);
                    reject(err);
                }
            })();
        });
    }, 60000);
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es2016" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */,
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "libReplacement": true,                           /* Enable lib replacement. */
    // "experimentalDecorators": true,                   /* Enable experimental support for legacy experimental decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */

    /* Modules */
    "module": "commonjs" /* Specify what module code is generated. */,
    "rootDir": "./src" /* Specify the root folder within your source files. */,
    "moduleResolution": "node10" /* Specify how TypeScript looks up a file from a given module specifier. */,
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */
    // "rewriteRelativeImportExtensions": true,          /* Rewrite '.ts', '.tsx', '.mts', and '.cts' file extensions in relative import paths to their JavaScript equivalent in output files. */
    // "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */
    // "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */
    // "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */
    // "noUncheckedSideEffectImports": true,             /* Check side effect imports. */
    "resolveJsonModule": true /* Enable importing .json files. */,
    // "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */

    /* Emit */
    "declaration": true /* Generate .d.ts files from TypeScript and JavaScript files in your project. */,
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./dist" /* Specify an output folder for all emitted files. */,
    // "removeComments": true,                           /* Disable emitting comments. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */
    // "isolatedDeclarations": true,                     /* Require sufficient annotation on exports so other tools can trivially generate declaration files. */
    // "erasableSyntaxOnly": true,                       /* Do not allow runtime constructs that are not part of ECMAScript. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */,
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */,

    /* Type Checking */
    "strict": true /* Enable all strict type-checking options. */,
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "strictBuiltinIteratorReturn": true,              /* Built-in iterators are instantiated with a 'TReturn' type of 'undefined' instead of 'any'. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  },
  "exclude": ["test", "tmp"]
}
</file>

<file path="docs/tasks/2025-05-09-input-integration-tests.md">
# Task: Enhance Input Sending Integration Tests

## Commit 1: Chore: Setup test infrastructure for input scenarios ✅ 2a495403a8ddf5b6132fee4d2798346e8dfcc934
**Description:**
Create a new directory `test/integration/input-tests/` to house tests specifically for input sending scenarios. Develop a helper script or set of functions, potentially in a new `test/integration/test-utils/input-helpers.ts` or by extending existing test utilities. This helper will streamline:
1.  Spawning `chopup` to wrap a dummy CLI script. The dummy scripts will be placed in `test/integration/input-tests/fixtures/scripts/`.
2.  Establishing an IPC connection to the `chopup` instance.
3.  Sending input strings using the `send-input` IPC mechanism.
4.  Capturing output from the dummy CLI to verify input reception.
5.  Ensuring robust cleanup using `tree-kill` for all processes and temporary files (IPC sockets, dummy script outputs).

**Verification:**
Create a basic "smoke" test within `test/integration/input-tests/smoke.test.ts`. This test will:
1.  Use the new helper to run `chopup` with a simple dummy script (e.g., `node test/integration/input-tests/fixtures/scripts/echo-input.js` which just echoes its stdin to stdout or a temp file).
2.  Send a predefined string (e.g., "hello-smoke") via the `send-input` command.
3.  Verify that the dummy script receives and correctly outputs "hello-smoke".
4.  Confirm that `chopup` and the dummy script processes are terminated cleanly by `tree-kill`.
5.  Check that the IPC socket path (e.g., from `chopup`'s startup message) is valid and used for communication.

---

## Commit 2: Feat: Add integration test for single character input (e.g., Y/N prompt) ✅ 25e4378346025150cacdda9799e264d1dc8139e6
**Description:**
1.  Create a dummy Node.js CLI script: `test/integration/input-tests/fixtures/scripts/yes-no-prompt.js`. This script will:
    *   Print a prompt like "Confirm? (y/n): ".
    *   Wait for a single character input from stdin ('y', 'Y', 'n', or 'N').
    *   Print a confirmation message based on the input (e.g., "Confirmed: yes" or "Confirmed: no").
    *   Exit.
2.  Create a new Vitest integration test file: `test/integration/input-tests/single-char.test.ts`.
3.  This test will use the helper from Commit 1 to wrap `yes-no-prompt.js` with `chopup`.
4.  The test will send "y\n" (simulating 'y' then Enter, as stdin is often line-buffered) using the `send-input` command (`chopup send-input --socket <socket-path> --input "y\n"`).
5.  Verify that the `yes-no-prompt.js` script outputs "Confirmed: yes".

**Verification:**
1.  Run `pnpm test test/integration/input-tests/single-char.test.ts`.
2.  Inspect `chopup` logs to ensure the input "y\n" was logged as sent.
3.  Verify the output from `yes-no-prompt.js` (captured by the test helper) matches "Confirmed: yes".
4.  Ensure all processes (`chopup`, `yes-no-prompt.js`) terminate cleanly.

---

## Commit 3: Feat: Add integration test for multi-character text input followed by Enter
**Description:**
1.  Create a dummy Node.js CLI script: `test/integration/input-tests/fixtures/scripts/text-entry-prompt.js`. This script will:
    *   Print a prompt like "Enter your name: ".
    *   Read a full line of text from stdin (terminated by a newline).
    *   Print the entered text, e.g., "Name entered: [entered_text]".
    *   Exit.
2.  Create a new Vitest integration test file: `test/integration/input-tests/text-entry.test.ts`.
3.  This test will wrap `text-entry-prompt.js` with `chopup`.
4.  The test will send a string like "John Doe\n" using the `send-input` command.
5.  Verify that `text-entry-prompt.js` outputs "Name entered: John Doe".

**Verification:**
1.  Run `pnpm test test/integration/input-tests/text-entry.test.ts`.
2.  Check `chopup` logs for the "John Doe\n" input.
3.  Verify the output from `text-entry-prompt.js` matches "Name entered: John Doe".
4.  Ensure clean process termination.

---

## Commit 4: Feat: Add integration test for selecting from a list of choices (numeric input)
**Description:**
1.  Create a dummy Node.js CLI script: `test/integration/input-tests/fixtures/scripts/choice-prompt.js`. This script will:
    *   Print a menu: "1. Option A\n2. Option B\n3. Option C\nEnter choice (1-3): ".
    *   Read a single digit from stdin followed by a newline.
    *   Print the selected option, e.g., "Selected: Option B" if "2" was entered.
    *   Handle invalid input gracefully (e.g., print "Invalid choice" and exit, or re-prompt - for simplicity, exit on invalid).
2.  Create a new Vitest integration test file: `test/integration/input-tests/list-choice.test.ts`.
3.  This test will wrap `choice-prompt.js` with `chopup`.
4.  The test will send "2\n" using the `send-input` command.
5.  Verify that `choice-prompt.js` outputs "Selected: Option B".
6.  (Optional) Add a test case for invalid input, e.g., sending "5\n" and verifying an "Invalid choice" message.

**Verification:**
1.  Run `pnpm test test/integration/input-tests/list-choice.test.ts`.
2.  Check `chopup` logs for the "2\n" input.
3.  Verify the output from `choice-prompt.js` matches "Selected: Option B".
4.  Ensure clean process termination. If the optional invalid input test is added, verify its expected outcome.

---

## Commit 5: Chore: Refactor input tests and enhance logging/cleanup
**Description:**
1.  Review all newly created tests in `test/integration/input-tests/`.
2.  Identify and refactor any duplicated code into the `test/integration/test-utils/input-helpers.ts` (or equivalent). This includes common patterns for setting up dummy scripts, spawning `chopup`, sending input, and verifying output.
3.  Enhance logging within the dummy CLI scripts (`test/integration/input-tests/fixtures/scripts/*.js`) to clearly indicate when input is received and what it is.
4.  Improve logging within the Vitest tests for clearer diagnostics upon failure (e.g., log the actual output vs. expected output).
5.  Double-check that all temporary files (dummy scripts if copied/generated per test, IPC sockets, output logs from dummy scripts if any) are rigorously cleaned up after each test run, possibly by enhancing the test helper's teardown logic.
6.  Ensure all tests use `node:` prefixed imports for built-in Node.js modules in the dummy scripts.

**Verification:**
1.  Run all tests in the `test/integration/input-tests/` directory: `pnpm test test/integration/input-tests/`. All tests must pass.
2.  Manually inspect the code for refactoring quality and improved logging.
3.  Temporarily introduce a failure in one of the dummy scripts or tests to observe the diagnostic logging.
4.  Verify that the `tmp/` directory (specifically `tmp/input-scenario-scripts/` and any test-specific subdirectories) is clean after all tests complete successfully. Check that no orphaned `chopup` or dummy script processes remain.
</file>

<file path="test/integration/input-tests/fixtures/scripts/yes-no-prompt.js">
#!/usr/bin/env node

const fs = require("node:fs");
const path = require("node:path");
const readline = require("node:readline");

const outputFilePath = process.argv[2];

if (!outputFilePath) {
	console.error("Error: yes-no-prompt.js - Output file path argument missing.");
	process.exit(1);
}

// Ensure the directory for the output file exists
const outputDir = path.dirname(outputFilePath);
if (!fs.existsSync(outputDir)) {
	fs.mkdirSync(outputDir, { recursive: true });
}

console.log("[YES_NO_PROMPT] Script started. Output file:", outputFilePath);
const writeStream = fs.createWriteStream(outputFilePath);
const rl = readline.createInterface({
	input: process.stdin,
	output: process.stdout, // Prompt will go to actual stdout, not the file
});

rl.question("Confirm? (y/n): ", (answer) => {
	const sanitizedAnswer = answer.trim().toLowerCase();
	let response;
	if (sanitizedAnswer === "y") {
		response = "Confirmed: yes";
	} else if (sanitizedAnswer === "n") {
		response = "Confirmed: no";
	} else {
		response = `Invalid input: ${answer}`;
	}
	console.log("[YES_NO_PROMPT] Received input:", answer);
	writeStream.write(`${response}\n`);
	writeStream.end(() => {
		console.log("[YES_NO_PROMPT] Exiting. Wrote response:", response);
		rl.close();
		process.exit(0);
	});
});
</file>

<file path="test/integration/test-utils/input-helpers.ts">
import { spawn, exec } from 'node:child_process';
import type { ChildProcess } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';
import fsSync from 'node:fs';
import treeKill from 'tree-kill';
import net from 'node:net';
// import { TMP_DIR } from './test-constants.ts'; // Removed faulty import

const ROOT_DIR = path.resolve(__dirname, '../../../'); // Adjust if utils are nested deeper
export const TMP_DIR = path.resolve(ROOT_DIR, 'tmp'); // Define TMP_DIR here

const CHOPUP_PATH = path.join(ROOT_DIR, 'dist/index.js'); // Assuming compiled output
const LOG_DIR_BASE = path.join(TMP_DIR, 'input-test-logs'); // Use the defined TMP_DIR

export interface ChopupInstance {
    process: ChildProcess;
    socketPath: string;
    logDir: string;
    stdoutData: string;
    stderrData: string;
    cleanup: () => Promise<void>;
    sendInput: (input: string) => Promise<void>;
    getWrappedProcessOutput: () => Promise<string>; // Placeholder, might need specific file
}

export async function spawnChopupWithScript(
    scriptPath: string,
    scriptArgs: string[] = [],
    logPrefix = 'input_test_',
    timeoutMs = 5000,
): Promise<ChopupInstance> {
    const instanceLogDir = path.join(LOG_DIR_BASE, `${logPrefix}_${Date.now()}`);
    console.log('[INPUT_HELPERS] Using logPrefix:', logPrefix, 'instanceLogDir:', instanceLogDir);
    await fs.mkdir(instanceLogDir, { recursive: true });

    let chopupProcess: ChildProcess | null = null;
    let socketPath: string | null = null;
    let stdoutData = '';
    let stderrData = '';

    const command = 'node';
    const args = [
        CHOPUP_PATH, // Path to the compiled chopup CLI
        'run',
        '--log-dir', instanceLogDir,
        '--log-prefix', logPrefix,
        '--',
        'node', scriptPath,
        ...scriptArgs // Only pass the output file as the first argument
    ];

    console.log('[INPUT_HELPERS] Spawning chopup process:', command, args.join(' '));
    chopupProcess = spawn(command, args, {
        cwd: ROOT_DIR,
        stdio: ['pipe', 'pipe', 'pipe'],
        detached: false,
    });

    const outputPromise = new Promise<string>((resolve, reject) => {
        const timeout = setTimeout(() => {
            reject(new Error(`Timeout waiting for chopup PID and socket. Stdout: ${stdoutData}, Stderr: ${stderrData}`));
        }, timeoutMs);

        chopupProcess?.stdout?.on('data', async (data) => {
            stdoutData += data.toString();
            process.stderr.write(`[CHOPUP_HELPER_STDOUT]: ${data.toString()}`);
            const socketMatch = stdoutData.match(/CHOPUP_SOCKET_PATH=(.*?)(?:\r\n|\n|$)/);
            if (socketMatch?.[1]) {
                socketPath = socketMatch[1].trim();
                clearTimeout(timeout);
                console.log('[INPUT_HELPERS] Socket path found:', socketPath);
                // Poll for socket file existence
                let socketExists = false;
                for (let i = 0; i < 30; i++) {
                    if (fsSync.existsSync(socketPath)) {
                        console.log(`[INPUT_HELPERS] Socket file confirmed to exist at: ${socketPath} (poll ${i})`);
                        socketExists = true;
                        break;
                    }
                    console.log(`[INPUT_HELPERS] Socket file NOT YET found at: ${socketPath} (poll ${i}), waiting 100ms...`);
                    await new Promise(r => setTimeout(r, 100));
                }
                if (!socketExists) {
                    const errorMsg = `[CHOPUP_HELPER_ERROR] IPC socket file not found at ${socketPath} after polling. Stdout: ${stdoutData}`;
                    console.error(errorMsg);
                    reject(new Error(errorMsg));
                    return;
                }
                resolve(socketPath);
            }
        });

        chopupProcess?.stderr?.on('data', (data) => {
            stderrData += data.toString();
            process.stderr.write(`[CHOPUP_HELPER_STDERR]: ${data.toString()}`);
        });

        chopupProcess?.on('error', (err) => {
            clearTimeout(timeout);
            reject(new Error(`chopup process error: ${err.message}. Stdout: ${stdoutData}, Stderr: ${stderrData}`));
        });

        chopupProcess?.on('exit', (code, signal) => {
            if (!socketPath) {
                clearTimeout(timeout);
                reject(new Error(`chopup process exited prematurely (code ${code}, signal ${signal}) before socket was found. Stdout: ${stdoutData}, Stderr: ${stderrData}`));
            }
        });
    });

    try {
        socketPath = await outputPromise;
        if (!fsSync.existsSync(socketPath)) {
            console.log('[INPUT_HELPERS] Waiting for socket file to exist');
            for (let i = 0; i < 50; i++) {
                if (fsSync.existsSync(socketPath)) break;
                await new Promise(r => setTimeout(r, 100));
            }
            if (!fsSync.existsSync(socketPath)) {
                throw new Error(`IPC socket file not found at ${socketPath} after delay. Stdout: ${stdoutData}`);
            }
        }
    } catch (error) {
        process.stderr.write(`[CHOPUP_HELPER_ERROR] Error after outputPromise: ${error instanceof Error ? error.message : String(error)}\n`);
        if (chopupProcess?.pid && !chopupProcess?.killed) {
            await new Promise<void>((resolveKill) => treeKill(chopupProcess.pid as number, 'SIGKILL', () => resolveKill()));
        }
        throw error;
    }

    const cleanup = async () => {
        console.log('[INPUT_HELPERS] cleanup: killing chopup process and removing log dir');
        if (chopupProcess?.pid && !chopupProcess?.killed) {
            const pid = chopupProcess.pid;
            await new Promise<void>((resolveKill, rejectKill) => {
                treeKill(pid, 'SIGKILL', (err) => {
                    if (err) {
                        console.error(`[CHOPUP_HELPER_CLEANUP] Error killing process tree for PID ${pid}:`, err);
                        rejectKill(err);
                    } else {
                        console.log(`[CHOPUP_HELPER_CLEANUP] Successfully killed process tree for PID ${pid}`);
                        resolveKill();
                    }
                });
            });
            // Poll for process to be fully gone
            let gone = false;
            for (let i = 0; i < 30; i++) {
                try {
                    process.kill(pid, 0);
                    console.log(`[INPUT_HELPERS] Process PID ${pid} still exists (poll ${i})`);
                } catch (e) {
                    gone = true;
                    console.log(`[INPUT_HELPERS] Process PID ${pid} is gone`);
                    break;
                }
                await new Promise(r => setTimeout(r, 100));
            }
            if (!gone) {
                const msg = `[INPUT_HELPERS] ERROR: Process PID ${pid} still exists after cleanup`;
                console.error(msg);
                throw new Error(msg);
            }
        }
        // Wait for socket file to be removed
        if (socketPath) {
            console.log(`[INPUT_HELPERS] Waiting for socket file to be removed: ${socketPath}`);
            let removed = false;
            for (let i = 0; i < 30; i++) {
                if (!fsSync.existsSync(socketPath)) {
                    console.log(`[INPUT_HELPERS] Socket file removed: ${socketPath}`);
                    removed = true;
                    break;
                }
                console.log(`[INPUT_HELPERS] Socket file still exists (poll ${i}): ${socketPath}`);
                await new Promise(r => setTimeout(r, 100));
            }
            if (!removed) {
                const msg = `[INPUT_HELPERS] ERROR: Socket file still exists after cleanup: ${socketPath}`;
                console.error(msg);
                throw new Error(msg);
            }
        }
        try {
            if (fsSync.existsSync(instanceLogDir)) {
                await fs.rm(instanceLogDir, { recursive: true, force: true });
            }
        } catch (e) {
            console.warn(`[CHOPUP_HELPER_CLEANUP] Could not remove test log dir ${instanceLogDir}:`, e);
        }
    };

    const sendInput = async (input: string) => {
        if (!socketPath) throw new Error('Cannot send input: IPC socket path not found.');
        if (!chopupProcess || chopupProcess.killed) throw new Error('Cannot send input: chopup process is not running.');
        console.log(`[INPUT_HELPERS] sendInput: Sending input "${input.trim()}" to socket ${socketPath}`);

        return new Promise<void>((resolve, reject) => {
            if (!socketPath) { // Null check for socketPath
                reject(new Error('[INPUT_HELPERS:sendInput:IPC_CLIENT] Socket path is null.'));
                return;
            }
            const client = net.createConnection({ path: socketPath });
            let hasResolved = false;

            const cleanupAndResolve = () => { // Removed val argument
                if (hasResolved) return;
                hasResolved = true;
                if (!client.destroyed) client.end();
                resolve(); // Resolve with no arguments for Promise<void>
            };

            const cleanupAndReject = (err: Error) => {
                if (hasResolved) return;
                hasResolved = true;
                if (!client.destroyed) client.end();
                reject(err);
            };

            client.on('connect', () => {
                console.log('[INPUT_HELPERS:sendInput:IPC_CLIENT] Connected to server.');
                const command = { command: 'send-input', input: input };
                client.write(JSON.stringify(command));
                console.log('[INPUT_HELPERS:sendInput:IPC_CLIENT] Sent command to server:', JSON.stringify(command));
            });

            client.on('data', (data) => {
                const response = data.toString();
                console.log('[INPUT_HELPERS:sendInput:IPC_CLIENT] Received data:', response);
                if (response === 'INPUT_SENT') {
                    console.log('[INPUT_HELPERS:sendInput:IPC_CLIENT] Server confirmed INPUT_SENT.');
                    cleanupAndResolve();
                } else if (response.startsWith('CHOPUP_INPUT_SEND_ERROR')) {
                    console.error('[INPUT_HELPERS:sendInput:IPC_CLIENT] Server error:', response);
                    cleanupAndReject(new Error(`Server error during send-input: ${response}`));
                } else {
                    console.warn('[INPUT_HELPERS:sendInput:IPC_CLIENT] Unexpected server response:', response);
                }
            });

            client.on('error', (err) => {
                console.error('[INPUT_HELPERS:sendInput:IPC_CLIENT] Connection error:', err.message);
                cleanupAndReject(new Error(`IPC Client error for send-input: ${err.message}`));
            });

            client.on('end', () => {
                console.log('[INPUT_HELPERS:sendInput:IPC_CLIENT] Disconnected from server (end event).');
                if (!hasResolved) {
                    console.warn('[INPUT_HELPERS:sendInput:IPC_CLIENT] Connection ended by server, assuming success if no error reported prior.');
                    cleanupAndResolve();
                }
            });

            setTimeout(() => {
                if (!hasResolved) {
                    cleanupAndReject(new Error('[INPUT_HELPERS:sendInput:IPC_CLIENT] Timeout waiting for server response.'));
                }
            }, 3000);
        });
    };

    const getWrappedProcessOutput = async (): Promise<string> => {
        const outputFile = scriptArgs[0];
        if (!outputFile) throw new Error('[INPUT_HELPERS] No outputFile set for getWrappedProcessOutput');
        console.log('[INPUT_HELPERS] Reading outputFile:', outputFile);
        try {
            const data = await fs.readFile(outputFile, 'utf8');
            return data;
        } catch (e) {
            console.error('[INPUT_HELPERS] Error reading outputFile:', outputFile, e);
            return '';
        }
    };


    return {
        process: chopupProcess,
        socketPath,
        logDir: instanceLogDir,
        stdoutData,
        stderrData,
        cleanup,
        sendInput,
        getWrappedProcessOutput,
    };
}
</file>

<file path="test/integration/spawn-wrapper-ipc-request-logs.test.ts">
import { describe, it, expect, beforeAll, afterAll, afterEach } from 'vitest';
import { spawn, execSync } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';
import treeKill from 'tree-kill';

const BASE_DIR = path.resolve(__dirname, '../../');
const TEST_DIR = path.join(BASE_DIR, 'tmp/ipc-tests');
const LOG_DIR = path.join(BASE_DIR, 'tmp/advanced_test_logs');
const LOG_PREFIX = 'ipc_test_';
const LOGGER_SCRIPT = path.join(TEST_DIR, 'continuous-logger.js');

function wait(ms: number) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

function killAllSpawnWrapperProcesses() {
    try {
        const output = execSync("ps aux | grep '[t]sx src/index.ts' || true", { encoding: 'utf8' });
        const lines = output.split('\n').filter(Boolean);
        for (const line of lines) {
            const parts = line.trim().split(/\s+/);
            const pid = Number.parseInt(parts[1], 10);
            if (!isNaN(pid)) {
                try {
                    process.kill(pid, 'SIGKILL');
                    // eslint-disable-next-line no-console
                    console.log(`[TEST] Killed leftover chopup process PID ${pid}`);
                } catch (e) {
                    // eslint-disable-next-line no-console
                    console.error(`[TEST] Failed to kill PID ${pid}:`, e);
                }
            }
        }
    } catch (e) {
        // eslint-disable-next-line no-console
        console.error('[TEST] Error sweeping for leftover processes:', e);
    }
}

describe('chopup IPC log chop integration', () => {
    let child: ReturnType<typeof spawn> | null = null;
    let childPGID: number | null = null;
    let logFilesBefore: string[] = [];
    let chopupPid: number | null = null;
    let wrapperLogPath: string;
    let wrapperLog: any;

    beforeAll(async () => {
        await fs.mkdir(LOG_DIR, { recursive: true });
        await fs.mkdir(TEST_DIR, { recursive: true });
        // Clean up previous files
        logFilesBefore = await fs.readdir(LOG_DIR);
        for (const f of logFilesBefore) {
            if (f.startsWith(LOG_PREFIX)) await fs.unlink(path.join(LOG_DIR, f));
        }
    });

    afterAll(async () => {
        if (child && child.pid) {
            await new Promise((resolve) => {
                treeKill(child.pid!, 'SIGKILL', (err) => {
                    if (err) {
                        // eslint-disable-next-line no-console
                        console.error('[TEST] Error killing process tree:', err);
                    } else {
                        // eslint-disable-next-line no-console
                        console.log(`[TEST] Killed process tree for PID ${child!.pid}`);
                    }
                    resolve(undefined);
                });
            });
        }
        // Clean up
        const logFilesAfter = await fs.readdir(LOG_DIR);
        for (const f of logFilesAfter) {
            if (f.startsWith(LOG_PREFIX)) await fs.unlink(path.join(LOG_DIR, f));
        }
    });

    afterEach(() => {
        return new Promise((resolve) => {
            if (child && child.pid) {
                treeKill(child.pid, 'SIGKILL', (err) => {
                    if (err) {
                        // eslint-disable-next-line no-console
                        console.error('[TEST] Error killing process tree:', err);
                    } else {
                        // eslint-disable-next-line no-console
                        console.log(`[TEST] Killed process tree for PID ${child.pid}`);
                    }
                    resolve(undefined);
                });
            } else {
                resolve(undefined);
            }
        });
    });

    it('should create log files on IPC chop request', async () => {
        // Start chopup with logger
        wrapperLogPath = path.join(LOG_DIR, 'test_wrapper_stdout.log');
        wrapperLog = await fs.open(wrapperLogPath, 'w');
        child = spawn('pnpm', [
            'exec', 'tsx', 'src/index.ts',
            '--log-dir', LOG_DIR,
            '--log-prefix', LOG_PREFIX,
            '--',
            'node', LOGGER_SCRIPT,
        ], {
            cwd: BASE_DIR,
            stdio: ['ignore', 'pipe', wrapperLog.fd],
            detached: true,
        });
        childPGID = child.pid || null;
        if (!child.pid) throw new Error('[TEST] Spawned process has no PID!');

        // Parse PID from chopup stdout
        let stdoutData = '';
        await new Promise<void>((resolve, reject) => {
            child!.stdout!.on('data', (data) => {
                stdoutData += data.toString();
                const match = stdoutData.match(/\[CHOPUP\] PID: (\d+)/);
                if (match) {
                    chopupPid = Number.parseInt(match[1], 10);
                    resolve();
                }
            });
            setTimeout(() => reject(new Error('Timeout waiting for PID output')), 10000);
        });
        expect(chopupPid).toBeGreaterThan(0);

        // Wait for logger to generate logs
        await wait(2000);

        // First log request
        const firstLogPath = await new Promise<string>((resolve, reject) => {
            const req = spawn('pnpm', [
                'exec', 'tsx', 'src/index.ts',
                '--pid', String(chopupPid),
            ], {
                cwd: BASE_DIR,
                stdio: ['ignore', 'pipe', 'inherit'],
            });
            let output = '';
            req.stdout.on('data', (data) => {
                output += data.toString();
            });
            req.on('close', () => {
                const match = output.match(/New log file created: (.*)/);
                if (match) resolve(match[1].trim());
                else {
                    // eslint-disable-next-line no-console
                    console.error('[TEST] Full output from --pid:', output);
                    reject(new Error('No log file path in output: ' + output));
                }
            });
        });
        const firstLogExists = await fs.access(firstLogPath).then(() => true, () => false);
        expect(firstLogExists).toBe(true);
        const firstLogLines = (await fs.readFile(firstLogPath, 'utf8')).split('\n').filter(Boolean).length;
        expect(firstLogLines).toBeGreaterThan(0);

        // Wait for more logs
        await wait(3000);

        // Second log request
        const secondLogPath = await new Promise<string>((resolve, reject) => {
            const req = spawn('pnpm', [
                'exec', 'tsx', 'src/index.ts',
                '--pid', String(chopupPid),
            ], {
                cwd: BASE_DIR,
                stdio: ['ignore', 'pipe', 'inherit'],
            });
            let output = '';
            req.stdout.on('data', (data) => {
                output += data.toString();
            });
            req.on('close', () => {
                const match = output.match(/New log file created: (.*)/);
                if (match) resolve(match[1].trim());
                else reject(new Error('No log file path in output: ' + output));
            });
        });
        expect(secondLogPath).not.toBe(firstLogPath);
        const secondLogExists = await fs.access(secondLogPath).then(() => true, () => false);
        expect(secondLogExists).toBe(true);
        const secondLogLines = (await fs.readFile(secondLogPath, 'utf8')).split('\n').filter(Boolean).length;
        expect(secondLogLines).toBeGreaterThan(0);
    }, 40000);
});
</file>

<file path="test/integration/spawn-wrapper-send-flag.test.ts">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { spawn, exec, ChildProcess } from 'node:child_process';
import type { ExecException } from 'node:child_process';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import { writeFileSync, unlinkSync, existsSync } from 'node:fs';
import treeKill from 'tree-kill';

const CLI_PATH = join(__dirname, '../../dist/index.js');
const TEST_SCRIPT_DIR = tmpdir();
const TEST_SCRIPT_NAME = 'input-prompt-test.js';
const TEST_SCRIPT_PATH = join(TEST_SCRIPT_DIR, TEST_SCRIPT_NAME);

const PROMPT_SCRIPT_LINES = [
    '// Excessive logging for test observability',
    'console.error("[PROMPT_SCRIPT] Started.");',
    'process.stdout.write("Are you sure? (y/n): ");',
    'process.stdin.setEncoding("utf8");',
    'process.stdin.once("data", (data) => {',
    '  const answer = data.toString().trim();',
    '  // Log received data for debugging',
    '  console.error(`[PROMPT_SCRIPT] Received: "${answer}"`);',
    '  if (answer === "y") {',
    '    console.log("Confirmed!");',
    '    process.exit(0);',
    '  } else {',
    '    console.log(`Cancelled! Received: ${answer}`);',
    '    process.exit(1);',
    '  }',
    '});',
];
const PROMPT_SCRIPT = PROMPT_SCRIPT_LINES.join('\n');

describe('spawn-wrapper send-input command', () => {
    beforeAll(() => {
        writeFileSync(TEST_SCRIPT_PATH, PROMPT_SCRIPT, 'utf8');
        console.log(`[TEST_SETUP] Created test script at ${TEST_SCRIPT_PATH}`);
    });

    afterAll(() => {
        if (existsSync(TEST_SCRIPT_PATH)) {
            unlinkSync(TEST_SCRIPT_PATH);
            console.log(`[TEST_TEARDOWN] Deleted test script at ${TEST_SCRIPT_PATH}`);
        }
    });

    it('should send input to a wrapped process via send-input command and allow it to proceed', async () => {
        let wrapperProcess: ChildProcess | undefined = undefined;
        let ipcSocketPath = '';

        try {
            // 1. Start the spawn-wrapper with the prompt script
            // Command: node dist/index.js run node /tmp/input-prompt-test.js
            console.log(`[TEST_RUN] Starting wrapper: node ${CLI_PATH} run node ${TEST_SCRIPT_PATH}`);
            wrapperProcess = spawn('node', [CLI_PATH, 'run', 'node', TEST_SCRIPT_PATH], {
                stdio: ['pipe', 'pipe', 'pipe'],
                detached: true, // Important for tree-kill later if needed
            });

            let wrapperOutput = '';
            const outputPromise = new Promise<void>((resolve) => {
                wrapperProcess?.stdout?.on('data', (data) => {
                    const text = data.toString();
                    wrapperOutput += text;
                    process.stderr.write(`[WRAPPER_STDOUT] ${text}`);
                    // Extract IPC socket path
                    const socketMatch = text.match(/IPC socket: (.*)/);
                    if (socketMatch?.[1]) {
                        ipcSocketPath = socketMatch[1].trim();
                        console.log(`[TEST_RUN] Extracted IPC Socket Path: ${ipcSocketPath}`);
                    }
                    // Resolve once prompt is seen from wrapper OR socket path is found (whichever indicates readiness)
                    if (text.includes('Are you sure? (y/n):') && ipcSocketPath) {
                        console.log('[TEST_RUN] Prompt detected from wrapper and socket path found.');
                        resolve();
                    }
                });
                wrapperProcess?.stderr?.on('data', (data) => {
                    process.stderr.write(`[WRAPPER_STDERR] ${data.toString()}`);
                });
            });

            // Wait for the wrapper to start and print the socket path and for the prompt to appear
            console.log('[TEST_RUN] Waiting for wrapper to be ready...');
            await outputPromise;

            expect(ipcSocketPath).not.toBe('');
            // Check for the wrapper's CHOPUP_CHILD_PID message
            expect(wrapperOutput).toContain('[chopup_wrapper] CHOPUP_CHILD_PID=');
            // Check for the wrapper's CHOPUP_SOCKET_PATH message
            expect(wrapperOutput).toContain('[chopup_wrapper] CHOPUP_SOCKET_PATH=');
            console.log(`[TEST_RUN] Wrapper ready. IPC Socket: ${ipcSocketPath}`);

            // 2. Use the send-input command to send 'y'
            const sendInputCommand = `node ${CLI_PATH} send-input --socket "${ipcSocketPath}" --input "y"`;
            console.log(`[TEST_RUN] Executing send-input: ${sendInputCommand}`);

            const sendInputResult = await new Promise<{ stdout: string, stderr: string, error: ExecException | null }>((resolveExec) => {
                exec(sendInputCommand, (error, stdout, stderr) => {
                    process.stderr.write(`[SEND_INPUT_STDOUT] ${stdout}`);
                    process.stderr.write(`[SEND_INPUT_STDERR] ${stderr}`);
                    // error can be null even if exit code is not 0 for exec
                    if (error && error.code !== 0) { // Consider error if code is non-zero
                        console.warn(`[TEST_RUN] send-input command potentially failed or had stderr. Error: ${error}, Code: ${error.code}`);
                        // Don't reject here, let assertions below handle it.
                    }
                    console.log('[TEST_RUN] send-input command completed execution.');
                    resolveExec({ stdout, stderr, error });
                });
            });

            // send-input client should now be silent on success or print specific errors to its stdout.
            // If an error object exists AND its code is not 0, it's a failure.
            // Or if stderr has content (unexpected for successful send-input).
            if (sendInputResult.error && (sendInputResult.error as ExecException).code !== 0) {
                throw new Error(`send-input failed with error: ${sendInputResult.error} and stderr: ${sendInputResult.stderr}`);
            }
            // If no actual exec error, check stdout for our controlled error messages
            expect(sendInputResult.stdout.trim()).toBe('CHOPUP_INPUT_SENT'); // Should be CHOPUP_INPUT_SENT on success
            expect(sendInputResult.stderr.trim()).toBe(''); // Stderr should also be empty on success


            // 3. Wait for the wrapped process to confirm and exit
            //    AND for the wrapper to print INPUT_SENT
            const finalChecksPromise = new Promise<void>((resolve, reject) => {
                let confirmedSeen = false;
                let inputSentSeen = false;

                const checkCompletion = () => {
                    if (confirmedSeen && inputSentSeen) {
                        resolve();
                    }
                };

                wrapperProcess?.stdout?.on('data', (data) => {
                    const text = data.toString();
                    wrapperOutput += text; // Continue accumulating
                    process.stderr.write(`[WRAPPER_STDOUT_LATE] ${text}`);
                    if (text.includes('[chopup_wrapper] CHOPUP_INPUT_SENT')) {
                        console.log('[TEST_RUN] Wrapper printed CHOPUP_INPUT_SENT.');
                        inputSentSeen = true;
                        checkCompletion();
                    }
                    if (text.includes('Confirmed!')) {
                        console.log('[TEST_RUN] Wrapper relayed \'Confirmed!\'.');
                        confirmedSeen = true;
                        checkCompletion();
                    }
                });

                wrapperProcess?.on('exit', (code) => {
                    console.log(`[TEST_RUN] Wrapper process exited eventually with code: ${code}`);
                    if (!confirmedSeen || !inputSentSeen) {
                        reject(new Error(`Wrapper exited before 'Confirmed!' (seen: ${confirmedSeen}) and 'CHOPUP_INPUT_SENT' (seen: ${inputSentSeen}) were observed. Final output: ${wrapperOutput}`));
                    } else if (code !== 0) {
                        reject(new Error(`Wrapper exited with non-zero code ${code} despite success signals.`));
                    }
                });

                // Timeout for this combined check
                setTimeout(() => {
                    if (!confirmedSeen || !inputSentSeen) {
                        reject(new Error(`Timeout waiting for 'Confirmed!' and 'CHOPUP_INPUT_SENT'. Confirmed seen: ${confirmedSeen}, INPUT_SENT seen: ${inputSentSeen}. Current wrapper output: ${wrapperOutput}`));
                    }
                }, 7000); // Shorter timeout for these specific messages after input is sent
            });

            await finalChecksPromise;

            // Double check wrapperOutput for key messages after everything.
            expect(wrapperOutput).toContain('[chopup_wrapper] CHOPUP_INPUT_SENT');
            expect(wrapperOutput).toContain('Confirmed!');

            const exitCode = await new Promise<number | null>((resolveExit) => {
                // If already exited, this will use the stored code. Otherwise, waits.
                if (wrapperProcess?.exitCode !== null) {
                    resolveExit(wrapperProcess.exitCode);
                } else {
                    wrapperProcess?.on('exit', resolveExit);
                }
            });
            expect(exitCode).toBe(0);

        } finally {
            if (wrapperProcess?.pid) {
                console.log(`[TEST_TEARDOWN] Killing wrapper process tree PID: ${wrapperProcess.pid}`);
                await new Promise<void>((resolveKill, rejectKill) => treeKill(wrapperProcess!.pid!, 'SIGKILL', (err) => err ? rejectKill(err) : resolveKill()));
                console.log(`[TEST_TEARDOWN] Wrapper process tree for PID ${wrapperProcess.pid} should be killed.`);
            }
            // Clean up socket file if it still exists (though chopup should do this)
            if (ipcSocketPath && existsSync(ipcSocketPath)) {
                try { unlinkSync(ipcSocketPath); } catch (e) { console.error(`Error deleting socket file: ${e}`); }
            }
        }
    }, 15000); // Increased timeout for multiple process interactions

    it('should fail gracefully if the target socket path is invalid', async () => {
        const invalidSocketPath = join(tmpdir(), 'nonexistent-chopup.sock');
        // Ensure it doesn't exist for a clean test
        if (existsSync(invalidSocketPath)) unlinkSync(invalidSocketPath);

        const sendInputCommand = `node ${CLI_PATH} send-input --socket "${invalidSocketPath}" --input "test"`;
        console.log(`[TEST_RUN_ERROR_SCENARIO] Executing send-input to invalid socket: ${sendInputCommand}`);

        let execStdout = '';
        let execStderr = '';
        let execError: ExecException | null = null;

        await new Promise<void>((resolve, reject) => {
            exec(sendInputCommand, (error, stdout, stderr) => {
                execStdout = stdout;
                execStderr = stderr;
                execError = error;
                process.stderr.write(`[SEND_INPUT_INVALID_SOCKET_STDOUT] ${stdout}`);
                process.stderr.write(`[SEND_INPUT_INVALID_SOCKET_STDERR] ${stderr}`);

                // send-input should exit with code 1, which exec treats as an error.
                if (error && error.code === 1 && stdout.includes('CHOPUP_INPUT_SEND_ERROR_NO_SERVER')) {
                    console.log('[TEST_RUN_ERROR_SCENARIO] send-input to invalid socket failed with expected error code and message.');
                    resolve();
                } else if (error) {
                    reject(new Error(`send-input to invalid socket failed with unexpected error: ${error.message}, stdout: ${stdout}, stderr: ${stderr}`));
                } else {
                    reject(new Error(`send-input to invalid socket should have failed but did not. stdout: ${stdout}, stderr: ${stderr}`));
                }
            });
        });

        // Additional assertions if needed, but the promise handles the main check.
        expect(execStdout).toContain('CHOPUP_INPUT_SEND_ERROR_NO_SERVER');
        expect(execError).not.toBeNull(); // Error object should be populated by exec
        if (execError) expect((execError as ExecException).code).toBe(1); // Cast to ExecException
        expect(execStderr.trim()).toBe(''); // No stderr output expected from send-input itself
    }, 10000);

    it('should fail gracefully if the wrapped process has already exited', async () => {
        let wrapperProcess: ChildProcess | undefined = undefined;
        let ipcSocketPath = '';
        const quickExitScriptContent = "console.log('Quick exit!'); process.exit(0);";
        const quickExitScriptPath = join(TEST_SCRIPT_DIR, 'quick-exit-script.js');
        writeFileSync(quickExitScriptPath, quickExitScriptContent, 'utf8');

        try {
            console.log(`[TEST_RUN_CHILD_EXITED] Starting wrapper with quick exit script: node ${CLI_PATH} run node ${quickExitScriptPath}`);
            wrapperProcess = spawn('node', [CLI_PATH, 'run', 'node', quickExitScriptPath], { stdio: ['pipe', 'pipe', 'pipe'] });

            let wrapperOutput = '';
            const socketPathPromise = new Promise<string>((resolve, reject) => {
                wrapperProcess?.stdout?.on('data', (data) => {
                    const text = data.toString();
                    wrapperOutput += text;
                    process.stderr.write(`[WRAPPER_QUICK_EXIT_STDOUT] ${text}`);
                    const match = text.match(/IPC socket: (.*)/);
                    if (match?.[1]) {
                        resolve(match[1].trim());
                    }
                });
                wrapperProcess?.on('exit', () => setTimeout(() => reject(new Error('Wrapper exited before IPC socket was found')), 50));
            });
            ipcSocketPath = await socketPathPromise;
            console.log(`[TEST_RUN_CHILD_EXITED] Wrapper started, IPC socket: ${ipcSocketPath}`);

            // Wait for the child (and thus wrapper) to likely exit
            await new Promise(resolve => wrapperProcess?.on('exit', resolve));
            console.log('[TEST_RUN_CHILD_EXITED] Wrapper process has exited.');
            await new Promise(r => setTimeout(r, 500)); // Give time for socket to be cleaned up / server to shut down fully

            const sendInputCommand = `node ${CLI_PATH} send-input --socket "${ipcSocketPath}" --input "test"`;
            console.log(`[TEST_RUN_CHILD_EXITED] Executing send-input: ${sendInputCommand}`);

            let execResult: { error: ExecException | null, stdout: string, stderr: string } | null = null;
            execResult = await new Promise((resolve, reject) => {
                exec(sendInputCommand, (error, stdout, stderr) => {
                    process.stderr.write(`[SEND_INPUT_CHILD_EXITED_STDOUT] ${stdout}`);
                    process.stderr.write(`[SEND_INPUT_CHILD_EXITED_STDERR] ${stderr}`);
                    // We expect an error because the server/socket should be gone or report no child
                    if (error && error.code === 1) {
                        if (stdout.includes('CHOPUP_INPUT_SEND_ERROR_NO_SERVER') || stdout.includes('CHOPUP_INPUT_SEND_ERROR_NO_CHILD')) {
                            console.log('[TEST_RUN_CHILD_EXITED] send-input failed as expected (NO_SERVER or NO_CHILD).');
                            resolve({ error, stdout, stderr });
                        } else {
                            reject(new Error(`send-input failed with code 1 but unexpected stdout: ${stdout}`));
                        }
                    } else if (error) {
                        reject(new Error(`send-input failed with unexpected error: ${error.message}, stdout: ${stdout}`));
                    }
                    else {
                        reject(new Error('send-input should have failed after wrapper exit, but it did not.'));
                    }
                });
            });


            expect(execResult).not.toBeNull();
            if (!execResult) throw new Error("execResult should not be null"); // type guard

            expect(execResult.error).not.toBeNull();
            if (execResult.error) expect((execResult.error as ExecException).code).toBe(1); // Cast to ExecException
            expect(execResult.stdout).toMatch(/CHOPUP_INPUT_SEND_ERROR_NO_SERVER|CHOPUP_INPUT_SEND_ERROR_NO_CHILD/);
            expect(execResult.stderr.trim()).toBe(''); // send-input shouldn't produce stderr output

        } finally {
            if (wrapperProcess?.pid) {
                await new Promise<void>((resolveKill, rejectKill) => treeKill(wrapperProcess!.pid!, 'SIGKILL', (err) => err ? rejectKill(err) : resolveKill()));
            }
            if (existsSync(quickExitScriptPath)) {
                unlinkSync(quickExitScriptPath);
            }
            // Socket should be cleaned by chopup, but as a fallback test might try
            if (ipcSocketPath && existsSync(ipcSocketPath)) {
                try { unlinkSync(ipcSocketPath); } catch (e) { /* ignore */ }
            }
        }
    }, 15000); // Increased timeout
});
</file>

<file path="package.json">
{
  "name": "chopup",
  "version": "1.0.0",
  "description": "A tool to wrap long-running processes and chop their logs based on file changes.",
  "main": "dist/index.js",
  "bin": {
    "chopup": "dist/index.js"
  },
  "scripts": {
    "dev": "tsx src/index.ts",
    "build": "pnpm run clean && tsc",
    "clean": "rimraf dist",
    "start": "node dist/index.js",
    "format": "biome format --write ./src",
    "lint": "biome lint --apply ./src",
    "test": "vitest run",
    "test:watch": "vitest --watch",
    "test:integration": "vitest run test/integration",
    "release": "semantic-release"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "packageManager": "pnpm@10.10.0",
  "publishConfig": {
    "access": "public"
  },
  "devDependencies": {
    "@biomejs/biome": "^1.9.4",
    "@types/node": "^22.15.17",
    "chokidar": "^4.0.3",
    "commander": "^13.1.0",
    "npm-name": "^8.0.0",
    "tree-kill": "^1.2.2",
    "tsx": "^4.19.4",
    "typescript": "^5.8.3",
    "vitest": "^1.6.1",
    "semantic-release": "^23.0.0",
    "@semantic-release/changelog": "^6.0.3",
    "@semantic-release/git": "^10.0.1",
    "@semantic-release/npm": "^11.0.0",
    "rimraf": "^5.0.5"
  }
}
</file>

<file path="README.md">
# chopup

A CLI tool to wrap long-running processes, chop output into segments, and send input to the wrapped process via IPC.

---

## Installation (Recommended: Global)

Install globally with pnpm:

```sh
pnpm add -g chopup
```

Or, to use directly with npx:

```sh
npx chopup run -- <command-to-wrap> [args...]
```

---

## Features
- Wraps and runs any user-specified command using the `run` subcommand (default).
- Captures stdout and stderr from the wrapped process.
- Segments/chops logs into new files in a specified log directory on IPC request.
- Allows sending input strings to the stdin of the wrapped process via IPC.
- Graceful shutdown and bulletproof process tree cleanup.
- IPC server for on-demand log chopping and input sending.

---

## Usage (Global CLI)

`chopup` now uses explicit subcommands: `run` (default), `request-logs`, and `send-input`.

### 1. Wrap a Process (using the `run` command)

This is the default command if no other subcommand is specified.

```sh
chopup run [--log-dir <log-dir>] [--log-prefix <prefix>] -- <command-to-wrap> [args...]
# OR (since run is default):
chopup [--log-dir <log-dir>] [--log-prefix <prefix>] -- <command-to-wrap> [args...]
```

**Example:**

```sh
chopup run -- node my-interactive-app.js
# Or simply:
chopup -- node my-interactive-app.js
```

- `--log-dir <path>`: Directory to store chopped log files (optional, defaults to a sanitized folder in the system temp dir, e.g., `/tmp/chopup_<project>_<cmd>`).
- `--log-prefix <prefix>`: Prefix for log file names (e.g., `myapp-`). Defaults to empty (timestamp only).
- `--`: Separator before the command to wrap.
- `<command-to-wrap> [args...]`: The command and arguments to run (e.g., `node my-app.js`).

**What happens:**
- The wrapped process runs.
- All stdout/stderr is captured by `chopup`.
- On startup, `chopup` logs its own PID and the IPC socket path to its stdout:
  ```
  [CHOPUP] PID: 12345
  [CHOPUP] IPC socket: /tmp/chopup_12345.sock 
  ```
  (Note: The actual socket path might be different, check the output.)
- Log chopping and input sending only occur when requested via IPC using other `chopup` commands (see below).

---

### 2. Trigger Log Chopping via IPC (from another shell)

Use the `request-logs` command:

```sh
chopup request-logs --socket <socket-path>
```

**Example:**

```sh
chopup request-logs --socket /tmp/chopup_12345.sock
```

- `--socket <socket-path>`: The IPC socket path of the running `chopup run` instance (from its startup log output).

**What happens:**
- The tool connects to the running `chopup run` instance via its IPC socket.
- It requests an immediate log chop.
- The path to the new log file is printed if logs were chopped, or a message if no new logs.

---

### 3. Sending Input to the Wrapped Process via IPC (from another shell)

Use the `send-input` command:

```sh
chopup send-input --socket <socket-path> --input "<string-to-send>"
```

**Log Suppression Note:**
- When running `send-input`, only the following will be printed to stdout:
  - `INPUT_SENT` (on success)
  - `INPUT_SEND_ERROR` or `INPUT_SEND_ERROR_NO_CHILD` (on failure)
- All other debug/info logs are suppressed for this command to ensure clean output for integration tests and scripting.
- Connection errors (e.g., invalid socket, exited process) are printed to stderr.

**Example:**

Imagine `my-interactive-app.js` (from step 1) prompts "Are you sure? (y/n): ".

```sh
chopup send-input --socket /tmp/chopup_12345.sock --input "y\n"
```

- `--socket <socket-path>`: The IPC socket path of the running `chopup run` instance.
- `--input "<string-to-send>"`: The string to send to the wrapped process's stdin. 
  - **Important**: If your wrapped process expects a newline to process the input (common for CLI prompts), make sure to include `\n` in your input string, e.g., `"y\n"` or `"some text then enter\n"`.

**What happens:**
- Connects to the `chopup run` instance via IPC.
- Sends the specified string to the stdin of the process `chopup` is wrapping.
- The `send-input` command will print a confirmation (e.g., `INPUT_SENT`) or an error message. No other logs will be printed.

---

## Example Workflow

1.  **Start `chopup run` in one shell with an interactive script:**
    ```sh
    # interactive-script.js might be something like:
    # process.stdout.write('Enter your name: ');
    # process.stdin.once('data', (data) => { console.log(`Hello, ${data.toString().trim()}!`); process.exit(); });

    chopup run -- node interactive-script.js
    ```
    - Note the IPC socket path printed (e.g., `/tmp/chopup_12345.sock`).

2.  **From another shell, send input to the script:**
    ```sh
    chopup send-input --socket /tmp/chopup_12345.sock --input "Alice\n"
    ```

3.  **Observe `interactive-script.js` in the first shell receiving the input and completing.**

4.  **From another shell, trigger a log chop:**
    ```sh
    chopup request-logs --socket /tmp/chopup_12345.sock
    ```

5.  **Check the log directory for segmented log files.**

---

## Local Development Usage (Alternative)

If you have `chopup` cloned locally:

**Run/Wrap a process:**
```sh
pnpm start -- run [--log-dir <log-dir>] [--log-prefix <prefix>] -- <command-to-wrap> [args...]
# Or (since run is default):
pnpm start -- [--log-dir <log-dir>] [--log-prefix <prefix>] -- <command-to-wrap> [args...]
```

**Request Logs via IPC:**
```sh
pnpm start -- request-logs --socket <socket-path>
```

**Send Input via IPC:**
```sh
pnpm start -- send-input --socket <socket-path> --input "<string-to-send>"
```

---

## Troubleshooting

- **No logs are chopped:** You must use the `chopup request-logs --socket <path>` command.
- **Input not sent / IPC not working:** 
  - Ensure you are using the correct IPC socket path from the running `chopup run` instance's output.
  - Verify the `chopup run` instance is still running.
  - Ensure the wrapped application is actually waiting for stdin if you are using `send-input`.
  - **Note:** For `send-input`, only `INPUT_SENT`, `INPUT_SEND_ERROR`, or `INPUT_SEND_ERROR_NO_CHILD` will be printed to stdout. Connection errors will be printed to stderr. All other logs are suppressed for this command.
- **Log files not appearing:** Check permissions on the log directory and that the `chopup run` process has not exited before logs could be written.
- **Process cleanup:** All child processes are killed on exit. If not, use `tree-kill` or manually clean up.

---

## Development

- Format: `pnpm format`
- Lint: `pnpm lint`
- Test: `pnpm test`
- Build: `pnpm build` (creates `dist/index.js`)

---

## License
ISC 

## CI/CD & Release

![CI](https://github.com/johnlindquist/spawn-wrapper/actions/workflows/ci.yml/badge.svg)
![Release](https://github.com/johnlindquist/spawn-wrapper/actions/workflows/release.yml/badge.svg)

- All PRs and pushes run CI (build, test, cross-platform smoke test).
- Merges to `main` trigger semantic-release:
  - Version bump, changelog, and npm publish (public).
  - Requires `NPM_TOKEN` secret in repo settings.
  - Uses [Conventional Commits](https://www.conventionalcommits.org/) for changelog and versioning.
- Excessive logging is enabled in CI and release for observability.

### Local Release Test

```sh
pnpm run release --dry-run
```

### NPM Publish

- Set `NPM_TOKEN` in GitHub repo secrets for publish to work.
- `publishConfig.access` is set to `public` in package.json.
</file>

<file path="test/integration/input-tests/single-char.test.ts">
import { describe, expect, it, beforeAll, afterAll } from 'vitest';
import path from 'node:path';
import fs from 'node:fs/promises';
import { spawnChopupWithScript, TMP_DIR } from '../test-utils/input-helpers';
import type { ChopupInstance } from '../test-utils/input-helpers';
import fsSync from 'node:fs';

const SCRIPT_NAME = 'yes-no-prompt.js';
const FIXTURES_DIR = path.resolve(__dirname, 'fixtures/scripts');
const scriptPath = path.join(FIXTURES_DIR, SCRIPT_NAME);

const testRunId = `single-char-tests_${Date.now()}`;
const baseLogDir = path.join(TMP_DIR, 'input-test-logs', testRunId);
const outputDir = path.join(baseLogDir, 'outputs');

describe('Single Character Input Test', () => {
    let chopupInstance: ChopupInstance | null = null;

    beforeAll(async () => {
        console.log('[SINGLE_CHAR_TEST] beforeAll: creating outputDir');
        await fs.mkdir(outputDir, { recursive: true });
        try {
            await fs.access(scriptPath, fs.constants.X_OK);
        } catch {
            await fs.chmod(scriptPath, '755');
        }
    });

    afterAll(async () => {
        console.log('[SINGLE_CHAR_TEST] afterAll: cleaning up chopupInstance');
        if (chopupInstance) {
            await chopupInstance.cleanup();
        }
    });

    it('should send "y" and verify "Confirmed: yes" output', async () => {
        console.log('[SINGLE_CHAR_TEST] Test start: y');
        const testId = 'single_char_y';
        const testRunId = `single-char-tests_${Date.now()}`;
        const baseLogDir = path.join(TMP_DIR, 'input-test-logs', testRunId);
        const outputDir = path.join(baseLogDir, 'outputs');
        await fs.mkdir(outputDir, { recursive: true });
        const outputFile = path.join(outputDir, `${testId}_output.txt`);
        console.log('[SINGLE_CHAR_TEST] Spawning chopupInstance');
        const logPrefix = `${testId}_${Date.now()}`;
        chopupInstance = await spawnChopupWithScript(scriptPath, [outputFile], logPrefix, 5000);
        console.log(`[SINGLE_CHAR_TEST] Chopup instance spawned. Socket path: ${chopupInstance.socketPath}`);

        // Aggressively wait for socket file to exist before proceeding
        let socketFileExists = false;
        for (let i = 0; i < 50; i++) { // Poll for up to 5 seconds
            if (chopupInstance.socketPath && fsSync.existsSync(chopupInstance.socketPath)) {
                console.log(`[SINGLE_CHAR_TEST] Socket file ${chopupInstance.socketPath} confirmed to exist (poll ${i}).`);
                socketFileExists = true;
                break;
            }
            console.log(`[SINGLE_CHAR_TEST] Waiting for socket ${chopupInstance.socketPath} to exist (poll ${i})...`);
            await new Promise(r => setTimeout(r, 100));
        }
        if (!socketFileExists) {
            throw new Error(`[SINGLE_CHAR_TEST] Socket file ${chopupInstance.socketPath} did not exist after extended polling.`);
        }

        await chopupInstance.sendInput('y');

        let output = '';
        let found = false;
        const start = Date.now();
        while (Date.now() - start < 1000) {
            output = await chopupInstance.getWrappedProcessOutput();
            if (output.trim() === 'Confirmed: yes') {
                found = true;
                break;
            }
            await new Promise(r => setTimeout(r, 100));
        }
        console.log('[SINGLE_CHAR_TEST] Output:', output.trim());
        expect(found).toBe(true);
        console.log('[SINGLE_CHAR_TEST] Cleaning up chopupInstance');
        await chopupInstance.cleanup();
        chopupInstance = null;
        console.log('[SINGLE_CHAR_TEST] Waiting 500ms after cleanup for OS to release socket');
        await new Promise(r => setTimeout(r, 500));
        console.log('[SINGLE_CHAR_TEST] Done waiting after cleanup');
        console.log('[SINGLE_CHAR_TEST] Test end: y');
    }, 5000);

    it('should send "N" and verify "Confirmed: no" output', async () => {
        console.log('[SINGLE_CHAR_TEST] Test start: N');
        const testId = 'single_char_N';
        const testRunId = `single-char-tests_${Date.now()}`;
        const baseLogDir = path.join(TMP_DIR, 'input-test-logs', testRunId);
        const outputDir = path.join(baseLogDir, 'outputs');
        await fs.mkdir(outputDir, { recursive: true });
        const outputFile = path.join(outputDir, `${testId}_output.txt`);
        if (chopupInstance) await chopupInstance.cleanup();
        chopupInstance = null;
        console.log('[SINGLE_CHAR_TEST] Spawning chopupInstance');
        const logPrefix = `${testId}_${Date.now()}`;
        chopupInstance = await spawnChopupWithScript(scriptPath, [outputFile], logPrefix, 5000);
        console.log(`[SINGLE_CHAR_TEST] Chopup instance spawned. Socket path: ${chopupInstance.socketPath}`);

        // Aggressively wait for socket file to exist before proceeding
        let socketFileExistsN = false;
        for (let i = 0; i < 50; i++) { // Poll for up to 5 seconds
            if (chopupInstance.socketPath && fsSync.existsSync(chopupInstance.socketPath)) {
                console.log(`[SINGLE_CHAR_TEST] Socket file ${chopupInstance.socketPath} confirmed to exist (poll ${i}).`);
                socketFileExistsN = true;
                break;
            }
            console.log(`[SINGLE_CHAR_TEST] Waiting for socket ${chopupInstance.socketPath} to exist (poll ${i})...`);
            await new Promise(r => setTimeout(r, 100));
        }
        if (!socketFileExistsN) {
            throw new Error(`[SINGLE_CHAR_TEST] Socket file ${chopupInstance.socketPath} did not exist after extended polling.`);
        }

        await chopupInstance.sendInput('N');

        let output = '';
        let found = false;
        const start = Date.now();
        while (Date.now() - start < 1000) {
            output = await chopupInstance.getWrappedProcessOutput();
            if (output.trim() === 'Confirmed: no') {
                found = true;
                break;
            }
            await new Promise(r => setTimeout(r, 100));
        }
        console.log('[SINGLE_CHAR_TEST] Output:', output.trim());
        expect(found).toBe(true);
        console.log('[SINGLE_CHAR_TEST] Cleaning up chopupInstance');
        await chopupInstance.cleanup();
        chopupInstance = null;
        console.log('[SINGLE_CHAR_TEST] Waiting 500ms after cleanup for OS to release socket');
        await new Promise(r => setTimeout(r, 500));
        console.log('[SINGLE_CHAR_TEST] Done waiting after cleanup');
        console.log('[SINGLE_CHAR_TEST] Test end: N');
    }, 5000);

    it('should send invalid input and verify "Invalid input: ..." output', async () => {
        console.log('[SINGLE_CHAR_TEST] Test start: invalid');
        const testId = 'single_char_invalid';
        const testRunId = `single-char-tests_${Date.now()}`;
        const baseLogDir = path.join(TMP_DIR, 'input-test-logs', testRunId);
        const outputDir = path.join(baseLogDir, 'outputs');
        await fs.mkdir(outputDir, { recursive: true });
        const outputFile = path.join(outputDir, `${testId}_output.txt`);
        if (chopupInstance) await chopupInstance.cleanup();
        chopupInstance = null;
        console.log('[SINGLE_CHAR_TEST] Spawning chopupInstance');
        const logPrefix = `${testId}_${Date.now()}`;
        chopupInstance = await spawnChopupWithScript(scriptPath, [outputFile], logPrefix, 5000);
        console.log(`[SINGLE_CHAR_TEST] Chopup instance spawned. Socket path: ${chopupInstance.socketPath}`);

        // Aggressively wait for socket file to exist before proceeding
        let socketFileExistsInvalid = false;
        for (let i = 0; i < 50; i++) { // Poll for up to 5 seconds
            if (chopupInstance.socketPath && fsSync.existsSync(chopupInstance.socketPath)) {
                console.log(`[SINGLE_CHAR_TEST] Socket file ${chopupInstance.socketPath} confirmed to exist (poll ${i}).`);
                socketFileExistsInvalid = true;
                break;
            }
            console.log(`[SINGLE_CHAR_TEST] Waiting for socket ${chopupInstance.socketPath} to exist (poll ${i})...`);
            await new Promise(r => setTimeout(r, 100));
        }
        if (!socketFileExistsInvalid) {
            throw new Error(`[SINGLE_CHAR_TEST] Socket file ${chopupInstance.socketPath} did not exist after extended polling.`);
        }

        await chopupInstance.sendInput('invalid');

        let output = '';
        let found = false;
        const start = Date.now();
        while (Date.now() - start < 1000) {
            output = await chopupInstance.getWrappedProcessOutput();
            if (output.trim().startsWith('Invalid input:')) {
                found = true;
                break;
            }
            await new Promise(r => setTimeout(r, 100));
        }
        console.log('[SINGLE_CHAR_TEST] Output:', output.trim());
        expect(found).toBe(true);
        console.log('[SINGLE_CHAR_TEST] Cleaning up chopupInstance');
        await chopupInstance.cleanup();
        chopupInstance = null;
        console.log('[SINGLE_CHAR_TEST] Waiting 500ms after cleanup for OS to release socket');
        await new Promise(r => setTimeout(r, 500));
        console.log('[SINGLE_CHAR_TEST] Done waiting after cleanup');
        console.log('[SINGLE_CHAR_TEST] Test end: invalid');
    }, 5000);
});
</file>

<file path="test/integration/input-tests/smoke.test.ts">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import path from 'node:path';
import fsSync from 'node:fs';
import { spawnChopupWithScript, TMP_DIR } from '../test-utils/input-helpers';
import type { ChopupInstance } from '../test-utils/input-helpers';
import fs from 'node:fs/promises';

const SCRIPT_NAME = 'echo-input.js';
const FIXTURES_DIR = path.resolve(__dirname, 'fixtures/scripts');
const scriptPath = path.join(FIXTURES_DIR, SCRIPT_NAME);

const testRunId = `smoke_test_${Date.now()}`;
const baseLogDir = path.join(TMP_DIR, 'input-test-logs', testRunId);
const outputDir = path.join(baseLogDir, 'outputs');

describe('Input Sending Smoke Test', () => {
    let chopupInstance: ChopupInstance | null = null;

    beforeAll(async () => {
        console.log('[SMOKE_TEST] beforeAll: creating outputDir');
        await fs.mkdir(outputDir, { recursive: true });
        try {
            await fs.access(scriptPath, fs.constants.X_OK);
        } catch {
            await fs.chmod(scriptPath, '755');
        }
    });

    afterAll(async () => {
        console.log('[SMOKE_TEST] afterAll: cleaning up chopupInstance');
        if (chopupInstance) {
            await chopupInstance.cleanup();
        }
    });

    it('should successfully send input to a wrapped script and verify its output', async () => {
        console.log('[SMOKE_TEST] Test start');
        const testId = 'smoke_test';
        const outputFile = path.join(outputDir, `${testId}_output.txt`);
        console.log('[SMOKE_TEST] Spawning chopupInstance');
        chopupInstance = await spawnChopupWithScript(scriptPath, [outputFile], testId, 5000);
        expect(chopupInstance).toBeDefined();
        expect(chopupInstance.socketPath).toBeDefined();
        expect(fsSync.existsSync(chopupInstance.socketPath)).toBe(true);

        const testInput = 'hello-smoke-test\n';
        console.log('[SMOKE_TEST] Sending input');
        await chopupInstance.sendInput(testInput);

        console.log('[SMOKE_TEST] Waiting 100ms for output');
        await new Promise(resolve => setTimeout(resolve, 100));

        console.log('[SMOKE_TEST] Checking output');
        const output = await chopupInstance.getWrappedProcessOutput();
        expect(output).toBe(testInput);

        console.log('[SMOKE_TEST] Cleaning up chopupInstance');
        await chopupInstance.cleanup();
        console.log('[SMOKE_TEST] chopupInstance cleanup complete');

        let socketGone = false;
        for (let i = 0; i < 10; i++) {
            console.log(`[SMOKE_TEST] Checking if socket exists (attempt ${i + 1}):`, chopupInstance.socketPath, fsSync.existsSync(chopupInstance.socketPath));
            if (!fsSync.existsSync(chopupInstance.socketPath)) {
                socketGone = true;
                console.log(`[SMOKE_TEST] Socket gone after ${i + 1} attempts.`);
                break;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        if (!socketGone) {
            console.error(`[SMOKE_TEST] ERROR: Socket file still exists after 1s: ${chopupInstance.socketPath}`);
        }
        console.log(`[SMOKE_TEST] Final socketGone: ${socketGone}, exists: ${fsSync.existsSync(chopupInstance.socketPath)}`);
        expect(socketGone).toBe(true);

        try {
            console.log('[SMOKE_TEST] Attempting to send input after cleanup');
            await chopupInstance.sendInput("after-cleanup");
            throw new Error("sendInput after cleanup should have failed but did not.");
        } catch (error: unknown) {
            if (error instanceof Error) {
                const message = error.message.toLowerCase();
                const isProcessNotRunningError = message.includes('chopup process is not running');
                const isConnectionError = message.includes('connect enoent') || message.includes('econnrefused');
                expect(isProcessNotRunningError || isConnectionError).toBe(true);
            } else {
                throw new Error('Caught an unknown error type during cleanup check.');
            }
        }
        console.log('[SMOKE_TEST] Test end');
    }, 5000);
});
</file>

<file path="src/index.ts">
#!/usr/bin/env node

import { program, Command } from "commander";
import path from "node:path";
import { spawn } from "node:child_process";
import chokidar from "chokidar"; // Import chokidar
import fs from "node:fs/promises"; // For file system operations
import fsSync from "node:fs"; // For sync unlink
import net from "node:net"; // For IPC
import treeKill from "tree-kill";
import os from "node:os";
import type { Command as CommanderCommand } from "commander"; // Use 'import type'

let effectiveArgv = process.argv;
if (effectiveArgv.length > 2 && effectiveArgv[2] === "--") {
    effectiveArgv = [
        effectiveArgv[0],
        effectiveArgv[1],
        ...effectiveArgv.slice(3),
    ];
}

// Placeholder for actual logic
interface LogBufferEntry {
    timestamp: number;
    type: "stdout" | "stderr";
    line: string;
}
// const logBuffer: LogBufferEntry[] = []; // This global one seems unused if logic is in Chopup class
// let lastChopTime = Date.now(); // Appears unused globally, Chopup class has its own
// let ipcServer: net.Server | null = null; // Appears unused globally, Chopup class has its own
// let childProcess: ReturnType<typeof spawn> | null = null; // Appears unused globally, Chopup class has its own

// Logging helpers for observability
function log(...args: unknown[]) {
    console.log(...args);
}
function logWarn(...args: unknown[]) {
    console.warn(...args);
}
function logError(...args: unknown[]) {
    console.error(...args);
}

function sanitizeForFolder(name: string): string {
    return name
        .replace(/[^a-zA-Z0-9_-]+/g, "_")
        .replace(/^_+|_+$/g, "")
        .slice(0, 40);
}

function getIpcSocketPath(pid: number): string {
    // Use a temp dir socket path, cross-platform
    const base = os.tmpdir();
    const sockName = `chopup_${pid}.sock`;
    return path.join(base, sockName);
}

const INPUT_SENT = "CHOPUP_INPUT_SENT";
const INPUT_SEND_ERROR = "CHOPUP_INPUT_SEND_ERROR";
const INPUT_SEND_ERROR_NO_CHILD = "CHOPUP_INPUT_SEND_ERROR_NO_CHILD";
const INPUT_SEND_ERROR_NO_SERVER = "CHOPUP_INPUT_SEND_ERROR_NO_SERVER"; // Defined
const INPUT_SEND_ERROR_BACKPRESSURE = "CHOPUP_INPUT_SEND_ERROR_BACKPRESSURE";

class Chopup {
    private command: string;
    private args: string[];
    private logDir: string;
    private socketPath: string;
    private ipcServer!: net.Server; // Definite assignment assertion
    private childProcess: ReturnType<typeof spawn> | null = null;
    private logBuffer: LogBufferEntry[] = [];
    private lastChopTime: number = Date.now();
    private activeConnections = new Set<net.Socket>();
    private exitInProgress = false;
    private cleanupInitiated = false; // To prevent multiple cleanup runs

    constructor(
        command: string,
        args: string[],
        logDir: string,
        socketPath?: string,
    ) {
        this.command = command;
        this.args = args;
        this.logDir = path.resolve(logDir);
        // Ensure logDir exists
        if (!fsSync.existsSync(this.logDir)) {
            fsSync.mkdirSync(this.logDir, { recursive: true });
        }
        this.socketPath =
            socketPath || path.join(this.logDir, `chopup-${process.pid}.sock`);
        // Log initial state
        // this.log(`Chopup instance created. PID: ${process.pid}, Command: ${command}, Args: ${args.join(' ')}, LogDir: ${this.logDir}, SocketPath: ${this.socketPath}`);
    }

    // Centralized logging for the wrapper
    private log(message: string): void {
        // Optional: Add timestamp or other context
        const logMessage = `[chopup_wrapper ${new Date().toISOString()}] ${message}\n`;
        // For now, logs to internal buffer and potentially a debug file if needed later
        // To avoid polluting stdout/stderr meant for the wrapped process or IPC.
        // If direct console logging is needed for wrapper's own operations:
        // console.log(logMessage); // Or console.error for errors
    }

    private error(message: string): void {
        const errorMessage = `[chopup_wrapper ERROR ${new Date().toISOString()}] ${message}\n`;
        // console.error(errorMessage);
    }

    // For IPC messages or critical wrapper status that needs to be on console
    private logToConsole(
        message: string,
        stream: "stdout" | "stderr" = "stdout",
    ): void {
        if (!process.stdout.writable && !process.stderr.writable) {
            // Both streams are closed, nowhere to log this critical message.
            // This can happen during late-stage shutdown.
            // console.log(`[logToConsole SKIPPED] ${message}`); // Log to internal if absolutely necessary
            return;
        }
        const formattedMessage = `[chopup_wrapper] ${message.endsWith("\\n") ? message : `${message}\\n`}`; // Use template literal
        if (stream === "stdout" && process.stdout.writable) {
            process.stdout.write(formattedMessage);
        } else if (process.stderr.writable) {
            // Fallback to stderr if stdout not writable or stream is stderr
            process.stderr.write(formattedMessage);
        } else {
            // If primary stream (stdout) was specified but not writable, and stderr is also not writable.
            // This case is covered by the initial check, but as a safeguard.
        }
    }

    private initializeSignalHandlers(): void {
        process.on("SIGINT", async () => {
            this.log("Received SIGINT. Starting graceful shutdown...");
            await this.doCleanup(null, "SIGINT");
            process.exit(130); // Standard exit code for SIGINT
        });

        process.on("SIGTERM", async () => {
            this.log("Received SIGTERM. Starting graceful shutdown...");
            await this.doCleanup(null, "SIGTERM");
            process.exit(143); // Standard exit code for SIGTERM
        });

        process.on("exit", (code) => {
            this.log(
                `Wrapper process exiting with code ${code}. Performing final sync cleanup.`,
            );
            this.attemptSocketUnlinkOnExit(); // Synchronous only
            this.log("Process.exit handler finished.");
        });
    }

    private setupIpcServer(): void {
        // Ensure old socket is removed if it exists
        if (fsSync.existsSync(this.socketPath)) {
            this.log(`Removing existing socket file: ${this.socketPath}`);
            fsSync.unlinkSync(this.socketPath);
        }

        this.ipcServer = net.createServer((socket) => {
            this.log("IPC client connected");
            this.activeConnections.add(socket);

            socket.on("data", async (data) => {
                try {
                    const message = data.toString();
                    this.log(`IPC data received: ${message}`);
                    const parsedData = JSON.parse(message);

                    if (parsedData.command === "request-logs") {
                        this.log("IPC command: request-logs");
                        this.chopLog(); // Assuming chopLog is a method of Chopup
                        if (!socket.destroyed) socket.write("LOGS_CHOPPED");
                    } else if (parsedData.command === "send-input") {
                        this.log(`IPC command: send-input, input: "${parsedData.input}"`);
                        if (
                            this.childProcess?.stdin &&
                            !this.childProcess.stdin.destroyed
                        ) {
                            // Optional chaining
                            this.childProcess.stdin.write(parsedData.input, (err) => {
                                if (err) {
                                    this.error(
                                        `Error writing to child process stdin: ${err.message}`,
                                    );
                                    if (!socket.destroyed) {
                                        try {
                                            socket.write(INPUT_SEND_ERROR, () => {
                                                if (!socket.destroyed) socket.end(); // Server ends on error after write
                                            });
                                        } catch (e: unknown) {
                                            // any to unknown
                                            const writeError = e as Error; // Type assertion
                                            this.error(
                                                `IPC write error (INPUT_SEND_ERROR): ${writeError.message}`,
                                            );
                                            if (!socket.destroyed) socket.end(); // Also end if immediate catch
                                        }
                                    }
                                } else {
                                    this.log(
                                        `Successfully wrote to child process stdin: "${parsedData.input}"`,
                                    );
                                    this.logToConsole(INPUT_SENT, "stdout");
                                    if (!socket.destroyed) {
                                        try {
                                            socket.write(INPUT_SENT); // Server does NOT end socket here.
                                            this.log(
                                                "[IPC_SERVER] Successfully sent INPUT_SENT to client. Client will flush, end socket, then exit.",
                                            );
                                        } catch (e: unknown) {
                                            // any to unknown
                                            const writeError = e as Error; // Type assertion
                                            this.error(
                                                `IPC write error (INPUT_SENT): ${writeError.message}`,
                                            );
                                            if (!socket.destroyed) socket.end(); // End if write fails
                                        }
                                    }
                                }
                            });
                        } else {
                            this.log(
                                "No child process or stdin not available for send-input.",
                            );
                            if (!socket.destroyed) {
                                try {
                                    socket.write(INPUT_SEND_ERROR_NO_CHILD, () => {
                                        if (!socket.destroyed) socket.end(); // Server ends on error after write
                                    });
                                } catch (e: unknown) {
                                    // any to unknown
                                    const writeError = e as Error; // Type assertion
                                    this.error(
                                        `IPC write error (INPUT_SEND_ERROR_NO_CHILD): ${writeError.message}`,
                                    );
                                    if (!socket.destroyed) socket.end(); // Also end if immediate catch
                                }
                            }
                        }
                    } else {
                        this.log("Unknown IPC command");
                        if (!socket.destroyed) socket.write("UNKNOWN_COMMAND");
                    }
                } catch (e: unknown) {
                    // any to unknown
                    const parseError = e as Error; // Type assertion
                    this.error(`Error processing IPC data: ${parseError.message}`);
                    if (!socket.destroyed) {
                        try {
                            socket.write("ERROR_PROCESSING_COMMAND");
                            socket.end();
                        } catch (se: unknown) {
                            const sendError = se as Error;
                            this.error(sendError.message);
                        } // any to unknown
                    }
                }
            });

            socket.on("error", (err) => {
                this.error(`IPC socket error: ${err.message}`);
                this.activeConnections.delete(socket);
            });

            socket.on("close", () => {
                this.log("IPC client disconnected");
                this.activeConnections.delete(socket);
            });
        });

        this.ipcServer.on("error", (err) => {
            this.error(`IPC server error: ${err.message}`);
            // Potentially try to recover or shut down gracefully
            this.doCleanup(1, null).then(() => process.exit(1));
        });

        this.ipcServer.listen(this.socketPath, () => {
            this.log(`IPC server listening on ${this.socketPath}`);
            // Add a small delay to ensure the socket file is created before announcing it
            setTimeout(() => {
                this.logToConsole(`CHOPUP_SOCKET_PATH=${this.socketPath}`); // For discovery by clients
                // Print plain socket path for test detection
                process.stdout.write(`CHOPUP_SOCKET_PATH=${this.socketPath}\n`);
            }, 50); // 50ms delay
        });
    }

    private chopLog(isFinalChop = false): void {
        if (this.logBuffer.length === 0 && !isFinalChop) {
            // this.log('No new logs to chop.');
            return;
        }

        const chopTime = Date.now();
        const logFileName = `log-${this.lastChopTime}-${chopTime}.log`;
        const logFilePath = path.join(this.logDir, logFileName);

        // Create a string from the log buffer
        // NOTE: This simple concatenation might be problematic for very large buffers.
        // Consider streaming or more efficient aggregation if performance issues arise.
        const logContent = this.logBuffer
            .map(
                (entry) =>
                    `[${new Date(entry.timestamp).toISOString()}] [${entry.type}] ${entry.line}`,
            )
            .join("");

        try {
            fsSync.writeFileSync(logFilePath, logContent);
            this.log(`Logs chopped to ${logFilePath}`);
        } catch (e: unknown) {
            // any to unknown
            const writeError = e as Error; // Type assertion
            this.error(
                `Failed to write chopped log to ${logFilePath}: ${writeError.message}`,
            );
        }

        // Clear the buffer and update the last chop time
        this.logBuffer = [];
        this.lastChopTime = chopTime;
    }

    private recordOutput(data: Buffer | string, type: "stdout" | "stderr"): void {
        const dataStr = data.toString();
        // Echo to wrapper's console if not suppressed (this IS the child process output)
        if (type === "stdout") {
            process.stdout.write(dataStr);
        } else {
            process.stderr.write(dataStr);
        }
        // Buffer for chopping
        this.logBuffer.push({ timestamp: Date.now(), type, line: dataStr });
    }

    private async performFinalCleanup(
        exitCode: number | null,
        signal: NodeJS.Signals | null,
    ): Promise<void> {
        this.log(
            `performFinalCleanup called. Exit code: ${exitCode}, Signal: ${signal}`,
        );
        this.chopLog(true); // Perform a final log chop

        // Close all active IPC connections
        this.log(
            `Closing ${this.activeConnections.size} active IPC connections...`,
        );
        for (const ipcClientSocket of this.activeConnections) {
            if (!ipcClientSocket.destroyed) {
                ipcClientSocket.end();
                ipcClientSocket.destroy(); // Ensure it's destroyed
            }
        }
        this.activeConnections.clear();
        this.log("Active IPC connections closed.");

        // Close IPC server
        if (this.ipcServer) {
            this.log("Closing IPC server...");
            await new Promise<void>((resolve, reject) => {
                this.ipcServer.close((err) => {
                    if (err) {
                        this.error(`Error closing IPC server: ${err.message}`);
                        // Don't reject, cleanup should continue
                    }
                    this.log("IPC server closed.");
                    resolve();
                });
            });
        }
        // Unlink socket file (moved to attemptSocketUnlinkOnExit for process.on('exit'))
        // this.attemptSocketUnlink();

        // Terminate child process tree
        if (this.childProcess?.pid && !this.childProcess.killed) {
            // Optional chaining
            this.log(
                `Terminating child process tree for PID: ${this.childProcess.pid}...`,
            );
            const childPid = this.childProcess.pid;
            await new Promise<void>((resolve, reject) => {
                let treeKillTimeout: NodeJS.Timeout | null = null;
                const killCallback = (err?: Error) => {
                    if (treeKillTimeout) clearTimeout(treeKillTimeout);
                    if (err) {
                        this.error(`tree-kill error for PID ${childPid}: ${err.message}`);
                    }
                    this.log(`Child process tree for PID ${childPid} terminated.`);
                    resolve();
                };

                treeKillTimeout = setTimeout(() => {
                    this.error(
                        `tree-kill for PID ${childPid} timed out after 2 seconds. Proceeding with cleanup.`,
                    );
                    killCallback(); // Call with no error to resolve the promise and continue cleanup
                }, 2000); // 2-second timeout for treeKill

                treeKill(childPid, "SIGKILL", killCallback);
            });
        } else {
            this.log("No active child process to terminate or already killed.");
        }
        this.log("performFinalCleanup finished.");
    }

    private attemptSocketUnlink(): void {
        if (this.socketPath && fsSync.existsSync(this.socketPath)) {
            try {
                this.log(
                    `[DEBUG] Socket file '${this.socketPath}' exists. Unlinking...`,
                );
                fsSync.unlinkSync(this.socketPath);
                this.log(
                    `[DEBUG] Socket file '${this.socketPath}' unlinked successfully.`,
                );
            } catch (e: unknown) {
                // any to unknown
                const unlinkError = e as Error; // Type assertion
                this.error(
                    `Error unlinking socket file ${this.socketPath}: ${unlinkError.message}`,
                );
            }
        } else if (this.socketPath) {
            this.log(
                `[DEBUG] Socket file '${this.socketPath}' does not exist or path is null. No unlink needed.`,
            );
        }
    }

    // This is the synchronous, last-ditch effort for process.on('exit')
    private attemptSocketUnlinkOnExit(): void {
        this.log(
            `[DEBUG] attemptSocketUnlinkOnExit: Received sockPath='${this.socketPath}' cleanupInitiated=${this.cleanupInitiated}`,
        );
        if (this.socketPath && fsSync.existsSync(this.socketPath)) {
            this.log(
                `[DEBUG] Socket file '${this.socketPath}' exists. Attempting synchronous unlink.`,
            );
            // Adding a small delay as requested, though its effectiveness in sync 'exit' is debatable.
            // For very fast server close, OS might not have released handle.
            const start = Date.now();
            while (Date.now() - start < 150) {
                /* busy wait for 150ms */
            }
            this.log("[DEBUG] Post-delay in attemptSocketUnlinkOnExit.");
            try {
                fsSync.unlinkSync(this.socketPath);
                this.log(
                    `[DEBUG] Socket file '${this.socketPath}' unlinked successfully on exit.`,
                );
            } catch (e: unknown) {
                // any to unknown
                const unlinkError = e as Error; // Type assertion
                // Log to console if possible, as this is a last chance
                const errorMsg = `[DEBUG] Error unlinking socket file ${this.socketPath} on exit: ${unlinkError.message}`;
                if (process.stderr.writable)
                    process.stderr.write(`${errorMsg}\\n`); // Template literal
                else if (process.stdout.writable)
                    process.stdout.write(`${errorMsg}\\n`); // Template literal
                // else console.log(errorMsg); // Fallback if streams are gone
            }
        } else if (this.socketPath) {
            // console.log(`[DEBUG] Socket file '${this.socketPath}' does not exist on exit. No unlink needed.`);
        }
    }

    private async doCleanup(
        exitCode: number | null = null,
        signal: NodeJS.Signals | null = null,
    ): Promise<void> {
        if (this.exitInProgress) {
            return;
        }
        this.exitInProgress = true;
        await this.performFinalCleanup(exitCode, signal);
    }

    public async run(): Promise<void> {
        this.logToConsole(
            `Starting wrapper for command: ${this.command} ${this.args.join(" ")}`,
        );
        this.logToConsole(`Log directory: ${this.logDir}`);
        this.logToConsole(`IPC socket path: ${this.socketPath}`);

        this.initializeSignalHandlers();
        this.setupIpcServer();

        this.childProcess = spawn(this.command, this.args, {
            stdio: ["pipe", "pipe", "pipe"], // stdin, stdout, stderr
        });

        this.logToConsole(`CHOPUP_CHILD_PID=${this.childProcess.pid}`);

        this.childProcess.stdout?.on("data", (data) => {
            this.recordOutput(data, "stdout");
        });

        this.childProcess.stderr?.on("data", (data) => {
            this.recordOutput(data, "stderr");
        });

        this.childProcess.on("error", (err) => {
            this.error(`Child process error: ${err.message}`);
            // this.doCleanup(1, null).then(() => process.exit(1)); // Ensure cleanup on child error
        });

        this.childProcess.on("close", async (code, signal) => {
            this.log(
                `Child process closed. Code: ${code}, Signal: ${signal}. Exit in progress: ${this.exitInProgress}`,
            );
            // If cleanup hasn't been initiated by a signal, do it now.
            if (!this.exitInProgress) {
                await this.doCleanup(code, signal);
            }
            process.exit(code ?? 1);
        });

        // Add process exit handler for guaranteed socket unlink
        process.on('exit', () => {
            if (this.socketPath && fsSync.existsSync(this.socketPath)) {
                try {
                    fsSync.unlinkSync(this.socketPath);
                    console.log(`[CHOPUP_WRAPPER] Synchronously unlinked socket file on exit: ${this.socketPath}`);
                } catch (e) {
                    console.error(`[CHOPUP_WRAPPER] Failed to unlink socket file on exit: ${this.socketPath}`, e);
                }
            } else {
                console.log(`[CHOPUP_WRAPPER] No socket file to unlink on exit: ${this.socketPath}`);
            }
        });
    }
}

// Helper function to extract command and args
// function extractCommandAndArgs(program: Command, args: string[]): { commandToExecute: string, argsForCommand: string[] } {
//     let commandToExecute: string;
//     let argsForCommand: string[];

//     if (program.opts().passthrough && program.opts().passthrough.length > 0) {
//         [commandToExecute, ...argsForCommand] = program.opts().passthrough;
//     } else if (args.length > 0) {
//         [commandToExecute, ...argsForCommand] = args;
//     } else {
//         console.error("Error: No command provided to run.");
//         process.exit(1);
//     }
//     return { commandToExecute, argsForCommand };
// }

// This is the main action for the 'run' command or default passthrough
async function mainAction(
    this: CommanderCommand,
    commandToRunArgs: string[],
    cmdOptionsObj: Record<string, unknown>,
) {
    // 'this' is the Command instance, thanks to .action(mainAction)
    // cmdOptionsObj will be the first arg if no commandToRunArgs, or the second if there are.
    // For passthrough, commandToRunArgs is empty.
    // For `chopup run cmd --arg1`, commandToRunArgs is ['cmd', '--arg1']

    // console.log("[DEBUG] mainAction called.");
    // console.log("[DEBUG] this (Command instance):", this);
    // console.log("[DEBUG] commandToRunArgs:", commandToRunArgs);
    // console.log("[DEBUG] cmdOptionsObj:", cmdOptionsObj); // This might be the command if not passthrough

    let commandToExecute: string;
    let argsForCommand: string[];
    const options = this.opts(); // Get options from the Command instance

    // console.log("[DEBUG] Parsed options (this.opts()):", options);

    if (options.passthrough && options.passthrough.length > 0) {
        // This case handles `chopup --log-dir /tmp/foo -- pnpm dev`
        // console.log("[DEBUG] Using passthrough arguments:", options.passthrough);
        [commandToExecute, ...argsForCommand] = options.passthrough;
    } else if (commandToRunArgs && commandToRunArgs.length > 0) {
        // This case handles `chopup run pnpm dev --log-dir /tmp/foo`
        // where commandToRunArgs = ['pnpm', 'dev']
        // console.log("[DEBUG] Using commandToRunArgs:", commandToRunArgs);
        [commandToExecute, ...argsForCommand] = commandToRunArgs;
    } else {
        // This case handles `chopup --log-dir /tmp/foo` (no command after options)
        // This should have been caught by requiredOption or .command arugment checks
        // but if it somehow gets here, it's an error.
        console.error(
            "[ERROR] No command provided to run. Please specify a command after 'run' or use '--' for passthrough.",
        );
        this.help(); // Show help, which will exit
        return; // Keep linter happy, though help() exits.
    }

    // console.log("[DEBUG] Determined commandToExecute:", commandToExecute);
    // console.log("[DEBUG] Determined argsForCommand:", argsForCommand);

    if (!commandToExecute) {
        console.error(
            "[ERROR] Failed to determine the command to execute. Check your arguments.",
        );
        this.help();
        return;
    }

    const logDir = options.logDir || path.join(process.cwd(), "chopup-logs");
    const socketPath = options.socketPath; // Can be undefined, Chopup constructor handles default

    // console.log(`[DEBUG] Log directory for Chopup: ${logDir}`);
    // console.log(`[DEBUG] Socket path for Chopup: ${socketPath || 'Default (handled by Chopup)'}`);

    const wrapper = new Chopup(
        commandToExecute,
        argsForCommand,
        logDir,
        socketPath,
    );
    try {
        await wrapper.run();
    } catch (error: unknown) {
        const runError = error as Error & { stack?: string }; // Type assertion
        console.error(`[ERROR] Unhandled error in Chopup run: ${runError.message}`);
        console.error(runError.stack);
        process.exit(1);
    }
}

program
    .name("chopup")
    .description(
        "Wraps a long-running process, monitors files, and segments logs.",
    )
    .version("1.0.0")
    .enablePositionalOptions();

program
    .command("run", { isDefault: true })
    .description(
        "Run the specified command and wrap it. This is the default command if no other is specified. Arguments after '--' are also treated as the command to run (passthrough).",
    )
    .option(
        "-l, --log-dir <dir>",
        "Directory to store logs.",
        path.join(process.cwd(), "chopup-logs"),
    )
    .option(
        "-p, --log-prefix <prefix>",
        "Prefix for log file names (used by some tests, e.g., passthrough_test_)",
    )
    .option("-s, --socket-path <path>", "Specify a custom IPC socket path.")
    .passThroughOptions(true)
    .argument(
        "[command_to_run_arg_array...]",
        "The command and its arguments to run (e.g., 'node my-script.js arg1'). Not used if -- is present.",
    )
    .action(mainAction); // Pass mainAction directly

program
    .command("request-logs")
    .description(
        "Requests the currently running chopup instance to chop and save logs.",
    )
    .requiredOption(
        "--socket <path>",
        "IPC socket path of the running chopup instance (from its startup logs).",
    )
    .action(async (options) => {
        const client = net.createConnection({ path: options.socket }, () => {
            console.log("[IPC_CLIENT] Connected to server.");
            client.write("REQUEST_LOGS");
        });
        client.on("data", (data) => {
            const response = data.toString();
            if (response === "NO_NEW_LOGS") {
                console.log("[IPC_CLIENT] Server responded: No new logs to chop.");
            } else if (response.startsWith("ERROR_")) {
                console.error(`[IPC_CLIENT] Server error: ${response}`);
            } else {
                console.log(`[IPC_CLIENT] Logs chopped to: ${response}`);
            }
            client.end();
        });
        client.on("error", (err) => {
            console.error("[IPC_CLIENT_ERROR] Connection error:", err.message);
        });
        client.on("end", () => {
            console.log("[IPC_CLIENT] Disconnected from server.");
        });
    });

// Helper to suppress logs except for allowed send-input responses
function suppressSendInputLogs() {
    // console.error('DEBUG: Suppressing all console output for send-input'); // For debugging the suppressor itself
    const noOp = () => { };
    console.log = noOp;
    console.error = noOp;
    console.warn = noOp;
    // Note: This does not affect process.stdout.write or process.stderr.write directly.
}

program
    .command("send-input")
    .description(
        "Sends an input string to the stdin of the wrapped process via IPC.",
    )
    .requiredOption(
        "--socket <path>",
        "IPC socket path of the running chopup instance.",
    )
    .requiredOption(
        "--input <string>",
        "The string to send to the process stdin.",
    )
    .action(async (options) => {
        suppressSendInputLogs(); // Suppress internal logs from send-input client itself
        const anErrorOccurred = false; // This was 'let', but seems it's never reassigned. Changed to const.

        const connectAndSend = () => {
            const client = net.createConnection(options.socketPath);
            let hasExited = false;
            let anErrorFromServer = false; // Tracks if the error originated from server response or connection issue

            const exitGracefully = (code = 0, fromClose = false) => {
                if (hasExited) return;
                hasExited = true;

                if (!client.destroyed && !fromClose) {
                    // console.log('[send-input-client] exitGracefully: client not destroyed and not fromClose, calling client.end()');
                    client.end(); // This will trigger the 'close' event eventually.
                    // Do not call process.exit here directly; let 'close' handler do it.
                    return; // Important: return to avoid proceeding to process.exit if not fromClose
                }

                // If fromClose is true, or if client was already destroyed when exitGracefully was called initially.
                // console.log(`[send-input-client] exitGracefully: proceeding to process.exit(${code}) (fromClose: ${fromClose}, client.destroyed: ${client.destroyed})`);
                process.exit(code);
            };

            client.on("connect", () => {
                // console.log('[send-input-client] Connected to server');
                const command = { command: "send-input", input: options.input };
                client.write(JSON.stringify(command));
                // console.log('[send-input-client] Sent command to server');
                // Don't end the client stream here; wait for server's response (INPUT_SENT or error)
            });

            client.on("data", (data) => {
                const message = data.toString();
                const isError = message.startsWith("CHOPUP_INPUT_SEND_ERROR");
                const stream = isError ? process.stderr : process.stdout;
                anErrorFromServer = isError; // Set based on server message

                stream.write(`${message}\n`, () => {
                    // After flushing the message, client initiates closing its end.
                    // The 'close' event will handle process.exit.
                    if (!client.destroyed) {
                        // console.log('[send-input-client] data handler: flushed output, calling client.end()');
                        client.end();
                    }
                });
            });

            client.on("end", () => {
                // console.log('[send-input-client] Server closed the connection (client.on(end)). Will be followed by \'close\'.');
                // Client should ensure it also closes if server ends connection.
                // If client.end() hasn't been called, this ensures eventual 'close'.
                // However, typically 'data' or 'error' handlers would call client.end() first.
                if (!client.destroyed) client.end();
            });

            client.on("close", () => {
                // console.log(`[send-input-client] Connection closed (client.on(close)). Error from server: ${anErrorFromServer}`);
                exitGracefully(anErrorFromServer ? 1 : 0, true); // true for fromClose ensures process.exit
            });

            client.on("error", (err: unknown) => {
                // any to unknown
                const connError = err as Error & { code?: string }; // Type assertion
                // console.error(`[send-input-client] Connection error: ${connError.message}. Code: ${connError.code}`);
                anErrorFromServer = true; // Indicate an error occurred for exit code in 'close'
                let msgToSend = INPUT_SEND_ERROR;
                if (connError.code === "ECONNREFUSED" || connError.code === "ENOENT") {
                    msgToSend = INPUT_SEND_ERROR_NO_SERVER;
                }

                // Write the error message to stdout, then client.end() in callback.
                // process.exit will be handled by the 'close' event.
                process.stdout.write(`${msgToSend}\n`, () => {
                    if (!client.destroyed) {
                        // console.log('[send-input-client] error handler: flushed output, calling client.end()');
                        client.end();
                    }
                });
            });

            // Timeout for the whole operation
            setTimeout(() => {
                if (!hasExited) {
                    // console.error('[send-input-client] Operation timed out.');
                    // Output a generic error message as the server might be unresponsive
                    process.stdout.write(`${INPUT_SEND_ERROR_NO_SERVER}\n`, () => {
                        exitGracefully(1);
                    });
                }
            }, 5000); // 5-second timeout for send-input operation
        };

        if (!options.socketPath) {
            process.stdout.write(`${INPUT_SEND_ERROR_NO_SERVER}\n`, () =>
                process.exit(1),
            );
            return;
        }
        connectAndSend();
    });

// Add global --pid support for test compatibility
const globalPidIndex = effectiveArgv.findIndex((arg) => arg === "--pid");
if (globalPidIndex !== -1 && effectiveArgv[globalPidIndex + 1]) {
    const pid = effectiveArgv[globalPidIndex + 1];
    const socketPath = getIpcSocketPath(Number(pid));
    const client = net.createConnection({ path: socketPath }, () => {
        client.write("REQUEST_LOGS");
    });
    client.on("data", (data) => {
        const response = data.toString();
        if (response.startsWith("LOG_CHOPPED:")) {
            const logPath = response.replace("LOG_CHOPPED:", "").trim();
            console.log(`New log file created: ${logPath}`);
        } else if (response === "NO_NEW_LOGS") {
            console.log("No new logs to chop.");
        } else {
            console.error(`Server error: ${response}`);
        }
        client.end();
    });
    client.on("error", (err) => {
        console.error("[IPC_CLIENT_ERROR] Connection error:", err.message);
        process.exit(1);
    });
    client.on("end", () => {
        process.exit(0);
    });
    // Do not run commander if --pid is present
} else {
    program.parse(effectiveArgv);
}

// treeKill(childProcess.pid); // Example, ensure proper cleanup

// if (!process.argv.slice(2).length) {
//   program.outputHelp();
// }

const cleanupCalled = false; // Changed to const
</file>

</files>
